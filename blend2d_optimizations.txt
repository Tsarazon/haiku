================================================================================
HAIKU APP SERVER: AGG → BLEND2D MIGRATION - COMPLETION INSTRUCTIONS
================================================================================

PROJECT STATUS: 80% Complete - Critical Issues Remaining
TARGET: Full AGG removal from Haiku OS codebase
TIMELINE: Priority 1 tasks = 2 weeks, Priority 2 = 1 month, Priority 3 = 2 months

================================================================================
CRITICAL ISSUE #1: Custom Drawing Modes Use Direct Pixel Access
================================================================================

PROBLEM LOCATION:
- src/servers/app/drawing/Painter/drawing_modes/Blend2DDrawingModeCustom.h

AFFECTED MODES:
- B_OP_BLEND (averaging: (src + dst) / 2)
- B_OP_INVERT (RGB inversion: 255 - dst)
- B_OP_SELECT (conditional color swap based on pattern)
- B_OP_ERASE (pattern-based conditional erase)

ISSUE DESCRIPTION:
Current implementation uses get_pixel_ptr() to directly access BLImage pixel
data via makeMutable(), bypassing Blend2D's rendering pipeline. This causes:
- Loss of hardware acceleration
- Violation of Blend2D abstraction
- Potential race conditions
- Performance degradation

EXAMPLE OF PROBLEMATIC CODE:
```cpp
static inline uint32_t*
get_pixel_ptr(BLImage* image, int x, int y, BLImageData* data)
{
    if (!data->pixelData) {
        BLResult result = image->makeMutable(data);  // ❌ BYPASSES PIPELINE
    }
    uint32_t* pixels = (uint32_t*)data->pixelData;
    int stride = data->stride / 4;
    return &pixels[y * stride + x];
}
```

SOLUTION STRATEGY:
Implement these modes using Blend2D's proper rendering pipeline:

OPTION 1: Use Offscreen Compositing (Recommended)
1. Create temporary BLImage with same dimensions as target region
2. Render to offscreen buffer
3. Apply custom operation via BLContext with appropriate BLCompOp
4. Composite result back to main buffer

OPTION 2: Use BLContext Custom Rendering
Research if Blend2D supports custom compositing operators that could be
registered for these modes.

IMPLEMENTATION TASKS:

Task 1.1: Implement B_OP_BLEND via offscreen compositing
```cpp
// Pseudocode:
static void blend_pixel_blend_native(int x, int y, ...) {
    // 1. Create offscreen 1x1 BLImage
    // 2. Get destination pixel via BLContext::blitImage
    // 3. Average colors: (src + dst) / 2
    // 4. Write result via BLContext::fillRect with BL_COMP_OP_SRC_COPY
}
```

Task 1.2: Implement B_OP_INVERT via shader/filter if possible
Research: Does Blend2D support color inversion filters?
Fallback: Use offscreen compositing

Task 1.3: Implement B_OP_SELECT and B_OP_ERASE
These require pattern checking - may need hybrid approach

Task 1.4: Performance testing
Compare new implementations vs current direct access approach
Target: <5% performance degradation

================================================================================
CRITICAL ISSUE #2: Excessive Debug Output in Production Code
================================================================================

PROBLEM LOCATION:
- All files contain fprintf(stderr, ...) calls
- Most prevalent in:
  - src/servers/app/drawing/Painter/Painter.cpp
  - src/servers/app/drawing/Painter/Blend2dTextRenderer.cpp
  - src/servers/app/drawing/Painter/bitmap_painter/BitmapPainter.cpp
  - src/servers/app/font/FontEngine.cpp

ISSUE DESCRIPTION:
Every Blend2D API call that can fail has an fprintf error message. Problems:
- fprintf is blocking and slow
- Spams stderr in production builds
- No way to disable without recompiling
- Makes logs unreadable

EXAMPLE OF PROBLEMATIC CODE:
```cpp
BLResult result = fContext.fillPath(path);
if (result != BL_SUCCESS) {
    fprintf(stderr, "Painter::_FillPath() failed: %d\n", (int)result);
}
```

SOLUTION:
Create unified debug logging system

IMPLEMENTATION TASKS:

Task 2.1: Create debug logging header
File: src/servers/app/drawing/Painter/Blend2dDebug.h
```cpp
#ifndef BLEND2D_DEBUG_H
#define BLEND2D_DEBUG_H

#ifdef DEBUG
    #include <Debug.h>
    #define BLEND2D_ERROR(x...) debug_printf("[Blend2D ERROR] " x)
    #define BLEND2D_WARNING(x...) debug_printf("[Blend2D WARN] " x)
    #define BLEND2D_TRACE(x...) debug_printf("[Blend2D] " x)
#else
    #define BLEND2D_ERROR(x...)
    #define BLEND2D_WARNING(x...)
    #define BLEND2D_TRACE(x...)
#endif

#define BLEND2D_CHECK(expr, action) \
    do { \
        BLResult _result = (expr); \
        if (_result != BL_SUCCESS) { \
            BLEND2D_ERROR("%s:%d: %s failed with code %d\n", \
                __FILE__, __LINE__, #expr, (int)_result); \
            action; \
        } \
    } while (0)

#endif // BLEND2D_DEBUG_H
```

Task 2.2: Replace all fprintf calls with new macros
Pattern:
```cpp
// Before:
if (result != BL_SUCCESS) {
    fprintf(stderr, "Warning: operation failed: %d\n", (int)result);
}

// After:
BLEND2D_CHECK(result, /* recovery action */);
```

Affected files (search for "fprintf.*Blend2D" or "fprintf.*result"):
- Painter.cpp (~30 occurrences)
- Blend2dTextRenderer.cpp (~10 occurrences)
- BitmapPainter.cpp (~15 occurrences)
- FontEngine.cpp (~5 occurrences)
- PixelFormat.cpp (~3 occurrences)

Task 2.3: Add logging levels to DesktopSettings
Allow runtime control of debug output verbosity

================================================================================
PERFORMANCE ISSUE #1: SerializedPath Overhead
================================================================================

PROBLEM LOCATION:
- src/servers/app/font/FontCacheEntry.h
- struct SerializedPath

ISSUE DESCRIPTION:
Vector glyphs are serialized to byte buffer, then deserialized on every render:

```cpp
struct SerializedPath {
    uint32 commandCount;
    uint32 vertexCount;
    // Followed by: uint8 commands[] + BLPoint vertices[]

    static BLPath Deserialize(const uint8* buffer) {
        BLPath path;
        // Copy all commands and vertices - EXPENSIVE!
        for (uint32 i = 0; i < commandCount; i++) {
            // Build path from scratch each time
        }
        return path;
    }
};
```

PERFORMANCE IMPACT:
- Deserialization happens on EVERY glyph render
- For complex glyphs (CJK, Emoji): 50-200 path commands
- Overhead: ~5-10 microseconds per glyph

SOLUTION OPTIONS:

OPTION A: Cache BLPath directly (Recommended)
```cpp
struct GlyphCache {
    mutable BLPath cachedPath;  // Cache the BLPath object
    mutable BLImage cachedImage;

    // Thread safety: use atomic flag or lock
    mutable std::atomic<bool> pathInitialized;
};
```

OPTION B: Use BLPath reference counting
Research: Does BLPath support shallow copy/COW?
If yes, cache reference-counted path

OPTION C: Keep serialization but optimize
- Use BLPath::addPath() to clone
- Pre-allocate capacity in Deserialize()

IMPLEMENTATION TASKS:

Task 3.1: Benchmark current implementation
Create test that renders 1000 complex glyphs, measure time

Task 3.2: Implement OPTION A with thread safety
Add mutex to GlyphCache or use atomic flags

Task 3.3: Benchmark improved implementation
Target: 50% reduction in glyph rendering overhead

Task 3.4: Update FontCacheEntry::CreateGlyph
Remove serialization for outline glyphs if caching BLPath directly

================================================================================
PERFORMANCE ISSUE #2: Color Space Conversion in BitmapPainter
================================================================================

PROBLEM LOCATION:
- src/servers/app/drawing/Painter/bitmap_painter/BitmapPainter.cpp
- Method: _ConvertColorSpace()

ISSUE DESCRIPTION:
Double memory copy for color space conversion:
1. Allocate temporary BBitmap
2. Convert to RGBA32 via ImportBits()
3. Copy to BLImage

```cpp
void _ConvertColorSpace(BLImage& outImage) {
    BBitmap* conversionBitmap = new BBitmap(...);  // ❌ ALLOCATION
    conversionBitmap->ImportBits(...);              // ❌ COPY 1
    // Then copy to BLImage                         // ❌ COPY 2
}
```

SOLUTION:
Use Blend2D's format conversion directly

IMPLEMENTATION TASKS:

Task 4.1: Research BLImage format conversion API
Check if Blend2D can convert between formats in-place

Task 4.2: Implement direct conversion
Eliminate BBitmap intermediate

Task 4.3: Benchmark
Measure impact on bitmap drawing performance

================================================================================
IMPROVEMENT #1: Subpixel Rendering Quality
================================================================================

PROBLEM LOCATION:
- src/servers/app/drawing/Painter/drawing_modes/Blend2DDrawingModeSUBPIX.h
- Function: subpix_average_coverage()

CURRENT IMPLEMENTATION:
```cpp
static inline uint8
subpix_average_coverage(const uint8* covers)
{
    return (covers[0] + covers[1] + covers[2]) / 3;  // Simple average
}
```

ISSUE:
Simple averaging doesn't match human perception. Green contributes more to
perceived brightness than red or blue.

SOLUTION:
Use perceptually-weighted averaging (same as FontEngine LCD conversion):

```cpp
static inline uint8
subpix_average_coverage(const uint8* covers)
{
    // Perceptual weights: R=0.299, G=0.587, B=0.114
    return (covers[0] * 299 + covers[1] * 587 + covers[2] * 114) / 1000;
}
```

IMPLEMENTATION TASK:

Task 5.1: Update subpix_average_coverage() function
File: Blend2DDrawingModeSUBPIX.h, line ~30

Task 5.2: Visual testing
Compare before/after screenshots of LCD text rendering

================================================================================
IMPROVEMENT #2: Verify Alpha Masking Support
================================================================================

PROBLEM LOCATION:
- src/servers/app/drawing/Painter/PainterInterface.h
- Fields: fMaskedUnpackedScanline, fClippedAlphaMask

ISSUE:
These fields are stubs from AGG migration:
```cpp
void* fMaskedUnpackedScanline;  // AGG leftover?
void* fClippedAlphaMask;        // AGG leftover?
```

But Painter.cpp uses them:
```cpp
if (state->GetAlphaMask() != NULL) {
    fInternal.fMaskedUnpackedScanline = state->GetAlphaMask()->Scanline();
    fInternal.fClippedAlphaMask = state->GetAlphaMask()->Mask();
}
```

QUESTIONS:
1. Is alpha masking actually working?
2. Should these use Blend2D's mask API instead?
3. Or are they unused and can be removed?

IMPLEMENTATION TASKS:

Task 6.1: Trace usage of alpha masks
Search codebase for SetAlphaMask/GetAlphaMask usage

Task 6.2: Test alpha masking functionality
Create test case with semi-transparent shapes

Task 6.3: Implement proper Blend2D masking if broken
Use BLContext::clipToRect() with alpha or BLContext::setCompOp() with masks

================================================================================
IMPROVEMENT #3: Pattern Support Verification
================================================================================

PROBLEM:
Verify all BeOS/Haiku patterns work correctly with Blend2D

PATTERNS TO TEST:
- B_SOLID_HIGH ✅ (known working)
- B_SOLID_LOW ✅ (known working)
- B_MIXED_COLORS (checkerboard)
- B_TILED_BITMAP
- Custom 8x8 patterns

IMPLEMENTATION TASKS:

Task 7.1: Create pattern test application
Draw all pattern types side by side

Task 7.2: Verify PatternHandler implementation
File: src/servers/app/drawing/PatternHandler.h
Check if all pattern types are handled

Task 7.3: Test with BView pattern drawing
Ensure compatibility with existing apps

================================================================================
TESTING REQUIREMENTS
================================================================================

UNIT TESTS NEEDED:

Test Suite 1: Drawing Modes
- File: tests/servers/app/drawing/DrawingModesTest.cpp
- Tests:
  * All 6 native modes (COPY, OVER, ADD, SUBTRACT, MIN, MAX)
  * All 15 Porter-Duff alpha modes
  * All 4 custom modes (BLEND, INVERT, SELECT, ERASE)
  * Subpixel rendering for all modes

Test Suite 2: Primitives
- File: tests/servers/app/drawing/PrimitivesTest.cpp
- Tests:
  * Lines (straight, diagonal, anti-aliased)
  * Rectangles (filled, stroked, rounded)
  * Ellipses (filled, stroked, rotated)
  * Polygons (convex, concave, self-intersecting)
  * Bezier curves (quadratic, cubic)
  * Arcs (all quadrants)

Test Suite 3: Text Rendering
- File: tests/servers/app/font/TextRenderingTest.cpp
- Tests:
  * ASCII text (all styles: Regular, Bold, Italic)
  * Unicode (Latin Extended, Greek, Cyrillic)
  * CJK (Chinese, Japanese, Korean)
  * Emoji (color, monochrome)
  * RTL text (Arabic, Hebrew)
  * Font fallbacks
  * Subpixel rendering (grayscale vs LCD)

Test Suite 4: Bitmap Operations
- File: tests/servers/app/drawing/BitmapTest.cpp
- Tests:
  * Bitmap drawing (all color spaces)
  * Bitmap scaling (nearest, bilinear)
  * Bitmap tiling (B_TILE_BITMAP flag)
  * Alpha channel handling
  * Color space conversions

Test Suite 5: Transformations
- File: tests/servers/app/drawing/TransformTest.cpp
- Tests:
  * Translation
  * Rotation (0°, 45°, 90°, 180°, 270°)
  * Scaling (uniform, non-uniform)
  * Shearing
  * Combined transformations
  * Nested transformations

Test Suite 6: Clipping
- File: tests/servers/app/drawing/ClippingTest.cpp
- Tests:
  * Rectangular clipping
  * Complex region clipping
  * Nested clipping
  * Transformed clipping regions

Test Suite 7: Gradients
- File: tests/servers/app/drawing/GradientTest.cpp
- Tests:
  * Linear gradients (all directions)
  * Radial gradients
  * Radial focus gradients
  * Diamond gradients
  * Conic gradients
  * Multi-stop gradients
  * Gradient transformations

INTEGRATION TESTS:

Test App 1: BView Drawing Compatibility
- Create app that uses all BView drawing primitives
- Compare output with reference screenshots
- Verify no visual regressions

Test App 2: Performance Benchmark
- Measure rendering time for:
  * 10,000 lines
  * 1,000 filled rectangles
  * 100 complex polygons
  * 1,000 glyphs (ASCII + CJK)
  * Large bitmap scaling
- Compare with AGG baseline (if available)
- Target: Within 10% of AGG performance

Test App 3: Real Application Test
- Run Haiku's native applications:
  * Terminal (text rendering)
  * WebPositive (complex layout)
  * StyledEdit (text editing)
  * ShowImage (image display)
  * Tracker (icon rendering)
- Verify no visual glitches
- Check for performance issues

================================================================================
ARCHITECTURE CLEANUP (PRIORITY 3)
================================================================================

SIMPLIFICATION OPPORTUNITIES:

1. PixelFormat Layer
   Current: PixelFormat wraps Blend2D, maintains function pointers
   Question: Is this layer still necessary after full AGG removal?
   Action: Consider direct BLContext usage in Painter

2. PainterInterface
   Current: Contains legacy AGG type stubs
   Action: Remove all rasterizer/scanline/renderer_base stubs from defines.h

3. FontCacheEntry
   Current: Maintains separate cache from Blend2D
   Question: Can we use BLGlyphBuffer and Blend2D's font caching?
   Action: Research Blend2D font caching capabilities

================================================================================
DOCUMENTATION REQUIREMENTS
================================================================================

DOCUMENTATION TO CREATE:

1. Migration Guide (docs/develop/app_server/blend2d_migration.md)
   - Overview of AGG → Blend2D changes
   - API differences
   - Performance characteristics
   - Known issues and workarounds

2. Drawing Modes Reference (docs/develop/app_server/blend2d_drawing_modes.md)
   - Complete reference of all modes
   - Blend2D implementation details
   - Performance notes

3. Developer Guide (docs/develop/app_server/blend2d_development.md)
   - How to add new drawing primitives
   - Debug logging usage
   - Performance optimization tips
   - Common pitfalls

4. Testing Guide (docs/develop/app_server/blend2d_testing.md)
   - How to run test suites
   - Creating visual regression tests
   - Performance benchmarking procedures

================================================================================
CODE QUALITY IMPROVEMENTS
================================================================================

IMPROVEMENTS TO IMPLEMENT:

1. Error Handling
   - Replace all fprintf() with BLEND2D_CHECK macro
   - Add proper error recovery paths
   - Document expected vs exceptional failures

2. Comments
   - Add high-level comments to each complex function
   - Document why certain Blend2D APIs are used
   - Explain any workarounds

3. Code Organization
   - Group related functions together
   - Use consistent naming conventions
   - Remove dead code (AGG remnants)

4. Performance Annotations
   - Mark hot paths with comments
   - Document algorithmic complexity
   - Add optimization notes

================================================================================
TIMELINE AND PRIORITIES
================================================================================

WEEK 1-2 (CRITICAL - MUST COMPLETE):
✅ Fix custom drawing modes (Issue #1)
✅ Implement debug logging system (Issue #2)
✅ Create basic test suite
✅ Visual verification testing

WEEK 3-4 (HIGH PRIORITY):
✅ Optimize SerializedPath (Performance Issue #1)
✅ Fix color conversion (Performance Issue #2)
✅ Improve subpixel rendering (Improvement #1)
✅ Verify alpha masking (Improvement #2)

MONTH 2 (MEDIUM PRIORITY):
✅ Complete all unit tests
✅ Performance benchmarking
✅ Pattern support verification
✅ Integration testing with real apps

MONTH 3 (LOW PRIORITY - CLEANUP):
✅ Architecture simplification
✅ Documentation creation
✅ Code quality improvements
✅ Final polish

================================================================================
SUCCESS CRITERIA
================================================================================

MIGRATION IS COMPLETE WHEN:
✅ All AGG code removed from Haiku codebase
✅ All 200+ unit tests passing
✅ No visual regressions in test applications
✅ Performance within 10% of AGG baseline
✅ No crashes in 24-hour stress test
✅ All native Haiku apps working correctly
✅ Documentation complete and reviewed
✅ Code review approved by Haiku core team

================================================================================
CLAUDE CODE USAGE INSTRUCTIONS
================================================================================

TO USE THIS DOCUMENT WITH CLAUDE CODE:

1. Start with Priority 1 tasks (Week 1-2):
   $ claude code --task "Fix B_OP_BLEND using offscreen compositing"
   $ claude code --task "Create Blend2dDebug.h logging system"
   $ claude code --task "Replace all fprintf with BLEND2D_CHECK macro"

2. For each task:
   - Read relevant sections from this document
   - Analyze affected source files
   - Implement solution
   - Create unit test
   - Run test suite
   - Commit changes

3. Testing workflow:
   $ claude code --task "Create DrawingModesTest.cpp with all mode tests"
   $ cd haiku/build
   $ jam -q DrawingModesTest
   $ ./DrawingModesTest

4. Documentation workflow:
   $ claude code --task "Create blend2d_migration.md documentation"

5. For complex issues requiring research:
   $ claude code --research "Blend2D custom compositing operators API"
   $ claude code --research "BLPath reference counting and COW behavior"

6. For code reviews:
   $ claude code --review "src/servers/app/drawing/Painter/drawing_modes/"

================================================================================
CONTACT AND SUPPORT
================================================================================

For questions or issues with this migration:
- Haiku Development mailing list
- #haiku IRC channel on OFTC
- Haiku bug tracker (for bugs)

This migration is a community effort. Feel free to ask for help!

================================================================================
END OF INSTRUCTIONS
================================================================================
Last Updated: 2025-01-XX
Version: 1.0
Maintainer: Haiku App Server Team
