# Миграция ServerFont.cpp/h на blend2d

## Обзор изменений в ServerFont

ServerFont использует AGG только в двух местах:
1. **BoundingBoxConsumer** - класс для вычисления bounding box глифов
2. **agg::rect_i** - тип для хранения bounds глифов

Все остальное делегируется в GlyphLayoutEngine и FontCacheEntry.

---

## Изменения в структуре GlyphCache

**Файл:** `src/servers/app/font/FontCacheEntry.h`

### Было (AGG):
```cpp
struct GlyphCache {
	// ...
	agg::rect_i		bounds;      // AGG тип
	// ...
};
```

### Стало (blend2d):
```cpp
struct GlyphCache {
	GlyphCache(uint32 glyphIndex, uint32 dataSize, glyph_data_type dataType,
			const BLBox& bounds,  // ← BLBox вместо agg::rect_i
			float advanceX, float advanceY,
			float preciseAdvanceX, float preciseAdvanceY,
			float insetLeft, float insetRight)
		:
		glyph_index(glyphIndex),
		data((uint8*)malloc(dataSize)),
		data_size(dataSize),
		data_type(dataType),
		bounds(bounds),  // ← теперь BLBox
		advance_x(advanceX),
		advance_y(advanceY),
		precise_advance_x(preciseAdvanceX),
		precise_advance_y(preciseAdvanceY),
		inset_left(insetLeft),
		inset_right(insetRight),
		hash_link(NULL)
	{
	}

	~GlyphCache()
	{
		free(data);
	}

	uint32			glyph_index;
	uint8*			data;
	uint32			data_size;
	glyph_data_type	data_type;
	BLBox			bounds;  // ← blend2d BLBox
	float			advance_x;
	float			advance_y;
	float			precise_advance_x;
	float			precise_advance_y;
	float			inset_left;
	float			inset_right;

	GlyphCache*		hash_link;
};
```

**Критично:** BLBox использует double (x0, y0, x1, y1), тогда как agg::rect_i использовал int (x1, y1, x2, y2). Нужно обновить все места обращения к bounds.

---

## Изменения в FontCacheEntry.cpp

### Обновление CreateGlyph

**Было:**
```cpp
return fGlyphCache->CacheGlyph(glyphCode,
	engine->DataSize(), engine->DataType(), engine->Bounds(),  // agg::rect_i
	engine->AdvanceX(), engine->AdvanceY(),
	engine->PreciseAdvanceX(), engine->PreciseAdvanceY(),
	engine->InsetLeft(), engine->InsetRight());
```

**Стало:**
```cpp
// FontEngine::Bounds() теперь возвращает BLBox
return fGlyphCache->CacheGlyph(glyphCode,
	engine->DataSize(), engine->DataType(), engine->Bounds(),  // BLBox
	engine->AdvanceX(), engine->AdvanceY(),
	engine->PreciseAdvanceX(), engine->PreciseAdvanceY(),
	engine->InsetLeft(), engine->InsetRight());
```

### Хранение BLPath в кэше

Раз вы уже реализовали сериализацию BLPath, то в `glyph->data` можно хранить:

**Для векторных глифов (glyph_data_outline):**
```cpp
// Структура сериализованного BLPath
struct SerializedPath {
	uint32_t commandCount;
	uint32_t vertexCount;
	// Далее идут массивы:
	// uint8_t commands[commandCount];
	// BLPoint vertices[vertexCount];
};
```

**Для растровых глифов (mono/gray8/lcd):**
```cpp
// Сериализованный BLImage
struct SerializedImage {
	int width;
	int height;
	BLFormat format;
	// Далее пиксельные данные
	// uint8_t pixelData[height * width * bytesPerPixel];
};
```

---

## Изменения в ServerFont.h

**Минимальные изменения** - только убрать неиспользуемые включения AGG:

```cpp
// УДАЛИТЬ:
// #include <agg_bounding_rect.h>

// Все остальное остается без изменений
```

---

## Изменения в ServerFont.cpp

### 1. Удалить AGG include

```cpp
// УДАЛИТЬ:
// #include <agg_bounding_rect.h>
```

### 2. Обновить BoundingBoxConsumer

Это самое важное изменение. Класс использует AGG адаптеры для работы с векторными глифами.

**Новая версия BoundingBoxConsumer:**

```cpp
class BoundingBoxConsumer {
 public:
	BoundingBoxConsumer(Transformable& transform, BRect* rectArray,
			bool asString)
		:
		rectArray(rectArray),
		stringBoundingBox(INT32_MAX, INT32_MAX, INT32_MIN, INT32_MIN),
		fAsString(asString),
		fTransform(transform)
	{
	}

	bool NeedsVector() { return false; }
	void Start() {}
	void Finish(double x, double y) {}
	void ConsumeEmptyGlyph(int32 index, uint32 charCode, double x, double y) {}

	bool ConsumeGlyph(int32 index, uint32 charCode, const GlyphCache* glyph,
		FontCacheEntry* entry, double x, double y, double advanceX,
			double advanceY)
	{
		if (glyph->data_type != glyph_data_outline) {
			// Растровый глиф - используем готовый bounds
			const BLBox& r = glyph->bounds;  // ← теперь BLBox вместо agg::rect_i
			
			if (fAsString) {
				if (rectArray) {
					rectArray[index].left = r.x0 + x;
					rectArray[index].top = r.y0 + y;
					rectArray[index].right = r.x1 + x;
					rectArray[index].bottom = r.y1 + y;
				} else {
					stringBoundingBox = stringBoundingBox
						| BRect(r.x0 + x, r.y0 + y, r.x1 + x, r.y1 + y);
				}
			} else {
				rectArray[index].left = r.x0;
				rectArray[index].top = r.y0;
				rectArray[index].right = r.x1;
				rectArray[index].bottom = r.y1;
			}
		} else {
			// Векторный глиф - десериализуем BLPath и вычисляем bounds
			BLPath path;
			if (!_DeserializePath(glyph->data, glyph->data_size, path)) {
				return false;
			}

			// Трансформируем путь если нужно
			if (fAsString) {
				BLMatrix2D matrix = BLMatrix2D::makeTranslation(x, y);
				path.transform(matrix);
			}

			// Применяем общую трансформацию
			if (!fTransform.IsIdentity()) {
				BLMatrix2D matrix;
				_TransformableToMatrix(fTransform, matrix);
				path.transform(matrix);
			}

			// Получаем bounding box
			BLBox box;
			path.getBoundingBox(&box);

			if (rectArray) {
				rectArray[index] = BRect(box.x0, box.y0, box.x1, box.y1);
			} else {
				stringBoundingBox = stringBoundingBox
					| BRect(box.x0, box.y0, box.x1, box.y1);
			}
		}
		return true;
	}

	BRect*		rectArray;
	BRect		stringBoundingBox;

 private:
	bool _DeserializePath(const uint8* data, uint32 dataSize, BLPath& path)
	{
		if (data == NULL || dataSize < sizeof(uint32_t) * 2)
			return false;

		const uint32_t* header = reinterpret_cast<const uint32_t*>(data);
		uint32_t commandCount = header[0];
		uint32_t vertexCount = header[1];

		// Проверка размера
		size_t expectedSize = sizeof(uint32_t) * 2 
			+ commandCount * sizeof(uint8_t)
			+ vertexCount * sizeof(BLPoint);
		
		if (dataSize < expectedSize)
			return false;

		const uint8_t* commands = data + sizeof(uint32_t) * 2;
		const BLPoint* vertices = reinterpret_cast<const BLPoint*>(
			commands + commandCount);

		// Восстанавливаем путь
		path.clear();
		path.reserve(vertexCount);

		size_t vertexIndex = 0;
		for (uint32_t i = 0; i < commandCount; i++) {
			uint8_t cmd = commands[i];
			
			switch (cmd) {
				case BL_PATH_CMD_MOVE:
					if (vertexIndex >= vertexCount) return false;
					path.moveTo(vertices[vertexIndex++]);
					break;

				case BL_PATH_CMD_ON:  // lineTo
					if (vertexIndex >= vertexCount) return false;
					path.lineTo(vertices[vertexIndex++]);
					break;

				case BL_PATH_CMD_QUAD:
					if (vertexIndex + 1 >= vertexCount) return false;
					path.quadTo(vertices[vertexIndex], vertices[vertexIndex + 1]);
					vertexIndex += 2;
					break;

				case BL_PATH_CMD_CUBIC:
					if (vertexIndex + 2 >= vertexCount) return false;
					path.cubicTo(vertices[vertexIndex], 
						vertices[vertexIndex + 1],
						vertices[vertexIndex + 2]);
					vertexIndex += 3;
					break;

				case BL_PATH_CMD_CLOSE:
					path.close();
					break;

				default:
					return false;
			}
		}

		return true;
	}

	bool				fAsString;
	Transformable&		fTransform;
};
```

**Ключевые изменения:**

1. **Удалены AGG адаптеры** - больше не нужны `fPathAdaptor`, `fCurves`, `fContour`, etc.
2. **BLBox вместо agg::rect_i** - обратите внимание на использование `x0, y0, x1, y1` вместо `x1, y1, x2, y2`
3. **Прямой доступ к BLMatrix2D** - `fTransform.Matrix()` возвращает `BLMatrix2D` напрямую
4. **Десериализация BLPath** - используется ваша уже реализованная функция

---

## Обновление остальных мест использования bounds

### В файле ServerFont.cpp найти все места с `glyph->bounds`:

**Паттерн поиска:** `glyph->bounds`

**Было (AGG):**
```cpp
const agg::rect_i& r = glyph->bounds;
// доступ: r.x1, r.y1, r.x2, r.y2
```

**Стало (blend2d):**
```cpp
const BLBox& r = glyph->bounds;
// доступ: r.x0, r.y0, r.x1, r.y1
```

---

## Функция десериализации BLPath

Так как вы уже реализовали сериализацию, добавьте в FontCacheEntry публичный метод десериализации:

**Файл:** `src/servers/app/font/FontCacheEntry.h`

```cpp
class FontCacheEntry : public MultiLocker, public BReferenceable {
public:
	// ... существующие методы ...
	
	// Новый статический метод для десериализации
	static bool DeserializePath(const uint8* data, uint32 dataSize, BLPath& path);
	
	// Или можно сделать метод-член
	bool DeserializeGlyphPath(const GlyphCache* glyph, BLPath& path) const;
};
```

**Файл:** `src/servers/app/font/FontCacheEntry.cpp`

```cpp
// Статический вариант
bool
FontCacheEntry::DeserializePath(const uint8* data, uint32 dataSize, BLPath& path)
{
	if (data == NULL || dataSize < sizeof(uint32_t) * 2)
		return false;

	const uint32_t* header = reinterpret_cast<const uint32_t*>(data);
	uint32_t commandCount = header[0];
	uint32_t vertexCount = header[1];

	// Проверка размера
	size_t expectedSize = sizeof(uint32_t) * 2 
		+ commandCount * sizeof(uint8_t)
		+ vertexCount * sizeof(BLPoint);
	
	if (dataSize < expectedSize)
		return false;

	const uint8_t* commands = data + sizeof(uint32_t) * 2;
	const BLPoint* vertices = reinterpret_cast<const BLPoint*>(
		commands + commandCount);

	// Восстанавливаем путь
	path.clear();
	path.reserve(vertexCount);

	size_t vertexIndex = 0;
	for (uint32_t i = 0; i < commandCount; i++) {
		uint8_t cmd = commands[i];
		
		switch (cmd) {
			case BL_PATH_CMD_MOVE:
				if (vertexIndex >= vertexCount) return false;
				path.moveTo(vertices[vertexIndex++]);
				break;

			case BL_PATH_CMD_ON:  // lineTo
				if (vertexIndex >= vertexCount) return false;
				path.lineTo(vertices[vertexIndex++]);
				break;

			case BL_PATH_CMD_QUAD:
				if (vertexIndex + 1 >= vertexCount) return false;
				path.quadTo(vertices[vertexIndex], vertices[vertexIndex + 1]);
				vertexIndex += 2;
				break;

			case BL_PATH_CMD_CUBIC:
				if (vertexIndex + 2 >= vertexCount) return false;
				path.cubicTo(vertices[vertexIndex], 
					vertices[vertexIndex + 1],
					vertices[vertexIndex + 2]);
				vertexIndex += 3;
				break;

			case BL_PATH_CMD_CLOSE:
				path.close();
				break;

			default:
				return false;
		}
	}

	return true;
}

// Метод-член вариант
bool
FontCacheEntry::DeserializeGlyphPath(const GlyphCache* glyph, BLPath& path) const
{
	if (glyph == NULL || glyph->data_type != glyph_data_outline)
		return false;
	
	return DeserializePath(glyph->data, glyph->data_size, path);
}
```

---

## Упрощенная версия BoundingBoxConsumer

С учетом того, что десериализация вынесена в FontCacheEntry:

```cpp
class BoundingBoxConsumer {
 public:
	BoundingBoxConsumer(Transformable& transform, BRect* rectArray,
			bool asString)
		:
		rectArray(rectArray),
		stringBoundingBox(INT32_MAX, INT32_MAX, INT32_MIN, INT32_MIN),
		fAsString(asString),
		fTransform(transform)
	{
	}

	bool NeedsVector() { return false; }
	void Start() {}
	void Finish(double x, double y) {}
	void ConsumeEmptyGlyph(int32 index, uint32 charCode, double x, double y) {}

	bool ConsumeGlyph(int32 index, uint32 charCode, const GlyphCache* glyph,
		FontCacheEntry* entry, double x, double y, double advanceX,
			double advanceY)
	{
		if (glyph->data_type != glyph_data_outline) {
			// Растровый глиф - используем готовый bounds
			const BLBox& r = glyph->bounds;
			
			if (fAsString) {
				if (rectArray) {
					rectArray[index].left = r.x0 + x;
					rectArray[index].top = r.y0 + y;
					rectArray[index].right = r.x1 + x;
					rectArray[index].bottom = r.y1 + y;
				} else {
					stringBoundingBox = stringBoundingBox
						| BRect(r.x0 + x, r.y0 + y, r.x1 + x, r.y1 + y);
				}
			} else {
				rectArray[index].left = r.x0;
				rectArray[index].top = r.y0;
				rectArray[index].right = r.x1;
				rectArray[index].bottom = r.y1;
			}
		} else {
			// Векторный глиф - десериализуем BLPath
			BLPath path;
			if (!entry->DeserializeGlyphPath(glyph, path)) {
				return false;
			}

			// Трансформируем путь если нужно
			if (fAsString) {
				BLMatrix2D matrix = BLMatrix2D::makeTranslation(x, y);
				path.transform(matrix);
			}

			// Применяем общую трансформацию
			if (!fTransform.IsIdentity()) {
				// Transformable уже содержит BLMatrix2D!
				path.transform(fTransform.Matrix());
			}

			// Получаем bounding box
			BLBox box;
			path.getBoundingBox(&box);

			if (rectArray) {
				rectArray[index] = BRect(box.x0, box.y0, box.x1, box.y1);
			} else {
				stringBoundingBox = stringBoundingBox
					| BRect(box.x0, box.y0, box.x1, box.y1);
			}
		}
		return true;
	}

	BRect*		rectArray;
	BRect		stringBoundingBox;

 private:
	bool				fAsString;
	Transformable&		fTransform;
};
```

---

## Проверочный список изменений

### FontCacheEntry.h
- [ ] `GlyphCache::bounds` изменен с `agg::rect_i` на `BLBox`
- [ ] Добавлен метод `DeserializePath()` или `DeserializeGlyphPath()`

### FontCacheEntry.cpp
- [ ] Обновлен `CreateGlyph()` для использования `BLBox`
- [ ] Реализована десериализация BLPath

### ServerFont.h
- [ ] Удален `#include <agg_bounding_rect.h>`

### ServerFont.cpp
- [ ] Удален `#include <agg_bounding_rect.h>`
- [ ] Обновлен `BoundingBoxConsumer`:
  - Удалены AGG адаптеры
  - Используется `BLBox` вместо `agg::rect_i`
  - Используется `BLPath` для векторных глифов
  - Используется `fTransform.Matrix()` для доступа к матрице

---

## Важные отличия BLBox от agg::rect_i

| Свойство | agg::rect_i | BLBox |
|----------|-------------|-------|
| Левая граница | `x1` | `x0` |
| Верхняя граница | `y1` | `y0` |
| Правая граница | `x2` | `x1` |
| Нижняя граница | `y2` | `y1` |
| Тип | int | double |
| Проверка валидности | `is_valid()` | `x1 > x0 && y1 > y0` |

**КРИТИЧНО:** При конвертации не забывайте, что:
```cpp
// AGG
rect.x1, rect.y1, rect.x2, rect.y2

// blend2d
box.x0, box.y0, box.x1, box.y1
```

---

## Пример полной замены

**Было (AGG):**
```cpp
const agg::rect_i& r = glyph->bounds;
if (!r.is_valid())
    return;
IntRect glyphBounds(int32(r.x1 + x), int32(r.y1 + y - 1),
    int32(r.x2 + x + 1), int32(r.y2 + y + 1));
```

**Стало (blend2d):**
```cpp
const BLBox& r = glyph->bounds;
if (r.x1 <= r.x0 || r.y1 <= r.y0)
    return;
IntRect glyphBounds(int32(r.x0 + x), int32(r.y0 + y - 1),
    int32(r.x1 + x + 1), int32(r.y1 + y + 1));
```

---

## Тестирование

После внесения изменений проверить:

1. **Растровые глифы** (mono, gray8, lcd):
   - Правильность bounding box
   - Отсутствие смещений

2. **Векторные глифы** (outline):
   - Корректная десериализация BLPath
   - Правильная трансформация
   - Точность bounding box

3. **Трансформации**:
   - Вращение текста
   - Наклон (shear)
   - Масштабирование

4. **Граничные случаи**:
   - Пустые строки
   - Специальные символы
   - Очень большие/маленькие размеры шрифта