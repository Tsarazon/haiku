====================================================================
ИСПРАВЛЕННАЯ ИНСТРУКЦИЯ ПО РЕФАКТОРИНГУ INTEL iGPU ДРАЙВЕРА HAIKU OS
Удаление поддержки GPU старше Generation 6 (Sandy Bridge 2011+)
====================================================================

⚠️ ВАЖНО: ПОСЛЕ ТЩАТЕЛЬНОГО АНАЛИЗА КОДА И ДОКУМЕНТАЦИИ INTEL ⚠️

Эта инструкция создана после глубокой проверки кода проекта и официальной
документации Intel. Учтены все архитектурные особенности Gen 6+.

====================================================================
КРИТИЧЕСКИЕ НАХОДКИ ПРИ АНАЛИЗЕ
====================================================================

1. **SoC vs PCH архитектура** (КРИТИЧЕСКИ ВАЖНО!):
   Gen 6+ включает ДВА типа архитектуры:

   a) С PCH (Platform Controller Hub):
      - Sandy Bridge (Gen 6)
      - Ivy Bridge (Gen 7) - десктопные/мобильные варианты
      - Haswell (Gen 7)
      - Broadwell (Gen 8)
      - Skylake и новее (Gen 9+)

   b) SoC БЕЗ PCH (System-on-Chip):
      - ValleyView/Bay Trail (Gen 7!) - Atom SoC
      - CherryView/Braswell (Gen 8) - Atom SoC
      - Apollo Lake (Gen 9) - Atom/Pentium/Celeron SoC
      - Gemini Lake (Gen 9) - Pentium Silver/Celeron SoC
      - JasperLake (Gen 11) - вероятно SoC

2. **MCH/ICH регистры НЕЛЬЗЯ удалять!**
   Они используются SoC чипами (ValleyView, CherryView и др.)
   Эти чипы имеют pch_info = INTEL_PCH_NONE

3. **mmioIndex корректен для Gen 6+**
   Все Gen 6+ используют mmioIndex = 0 (проверка >= 3 корректна)

====================================================================
АНАЛИЗ ТЕКУЩЕЙ СТРУКТУРЫ
====================================================================

1. СИСТЕМА ОПРЕДЕЛЕНИЯ ГЕНЕРАЦИЙ (intel_extreme.h):

struct DeviceType::Generation():
- Возвращает 0 для неподдерживаемых GPU (< Gen 6)
- Возвращает 6-12 для поддерживаемых GPU
- ВАЖНО: ValleyView возвращает 7, хотя это SoC!

Текущие семейства (Gen 6+):
- INTEL_FAMILY_SER5 (0x00080000) - Intel Series 5 (Gen 6-8 с PCH)
- INTEL_FAMILY_SOC0 (0x00200000) - Atom SOC (БЕЗ PCH!)
- INTEL_FAMILY_LAKE (0x00400000) - Intel Lakes (Gen 9+)

Текущие группы (Gen 6+):
- INTEL_GROUP_SNB - SandyBridge (Gen 6, с PCH)
- INTEL_GROUP_IVB - IvyBridge (Gen 7, с PCH)
- INTEL_GROUP_HAS - Haswell (Gen 7, с PCH)
- INTEL_GROUP_VLV - ValleyView (Gen 7, SoC БЕЗ PCH!)
- INTEL_GROUP_CHV - CherryView (Gen 8, SoC БЕЗ PCH!)
- INTEL_GROUP_BDW - Broadwell (Gen 8, с PCH)
- INTEL_GROUP_SKY - SkyLake (Gen 9, с PCH)
- INTEL_GROUP_KBY - KabyLake (Gen 9, с PCH)
- и т.д.

====================================================================
ЗАДАЧИ ПО РЕФАКТОРИНГУ
====================================================================

ЗАДАЧА 1: ОЧИСТКА HEADER ФАЙЛОВ
--------------------------------

Файл: headers/private/graphics/intel_extreme/intel_extreme.h

1.1. Удалить устаревшие семейства (если есть):
   - Искать: INTEL_FAMILY_8xx, INTEL_FAMILY_9xx
   - Искать: INTEL_GROUP_G4x
   - УДАЛИТЬ если найдены

1.2. DeviceType::Generation() - ОСТАВИТЬ БЕЗ ИЗМЕНЕНИЙ
   Функция корректна для Gen 6+

1.3. DeviceType::SupportsHDMI() - ПРОВЕРИТЬ:
   - Если упоминается INTEL_GROUP_G4x - УДАЛИТЬ эту проверку
   - Код должен быть:
   ```cpp
   bool SupportsHDMI() const
   {
       return InFamily(INTEL_FAMILY_SER5) || InFamily(INTEL_FAMILY_SOC0)
           || InFamily(INTEL_FAMILY_LAKE);
   }
   ```

1.4. MCH/ICH и PCH регистры - ОСТАВИТЬ ВСЕ!
   - MCH_* и ICH_* определения НУЖНЫ для SoC чипов
   - PCH_* определения нужны для PCH платформ
   - НЕ УДАЛЯТЬ эти определения!

1.5. Комментарии в регистрах:
   - Найти упоминания "i965 and up only", "Gen 3", "Gen 4", "Gen 5"
   - ЗАМЕНИТЬ на: "Gen 6+ (Sandy Bridge 2011 and newer)"


ЗАДАЧА 2: DRIVER.CPP - СПИСОК УСТРОЙСТВ
----------------------------------------

Файл: src/add-ons/kernel/drivers/graphics/intel_extreme/driver.cpp

2.1. Массив kSupportedDevices (строки ~44):
   - Текущий список начинается с Gen 6 (Sandy Bridge)
   - ПРОВЕРИТЬ: нет ли старых device ID
   - Список корректен, НИЧЕГО НЕ МЕНЯТЬ

2.2. Комментарии в kSupportedDevices:
   - Найти закомментированный ValleyView (#if 0 ... #endif)
   - ОСТАВИТЬ закомментированным или ПРОВЕРИТЬ поддержку


ЗАДАЧА 3: INTEL_EXTREME.CPP - ИНИЦИАЛИЗАЦИЯ
--------------------------------------------

Файл: src/add-ons/kernel/drivers/graphics/intel_extreme/intel_extreme.cpp

3.1. Проверка минимальной генерации - ОСТАВИТЬ:
   ```cpp
   if (info.device_type.Generation() < 6) {
       ERROR("GPU Generation %d is not supported. "
           "Minimum requirement: Gen 6 (Sandy Bridge, 2011+)\n",
           info.device_type.Generation());
       ERROR("Your GPU: %s\n", info.device_identifier);
       return B_NOT_SUPPORTED;
   }
   ```

3.2. MMIO Index - МОЖНО УПРОСТИТЬ (опционально):
   БЫЛО:
   ```cpp
   int mmioIndex = 1;
   if (info.device_type.Generation() >= 3) {
       mmioIndex = 0;
   }
   ```

   СТАЛО:
   ```cpp
   // Gen 6+ always uses index 0 for MMIO mapping
   int mmioIndex = 0;
   ```

3.3. Register blocks setup - **НЕ УДАЛЯТЬ ELSE БЛОК!**
   Код на строках ~270-310:
   ```cpp
   if (hasPCH) {
       // PCH based platforms (SandyBridge, IvyBridge, Haswell, etc.)
       blocks[REGISTER_BLOCK(REGS_NORTH_SHARED)] = PCH_NORTH_SHARED_REGISTER_BASE;
       // ... и т.д.
   } else {
       // SoC platforms WITHOUT PCH (ValleyView, CherryView, Apollo Lake, etc.)
       blocks[REGISTER_BLOCK(REGS_NORTH_SHARED)] = MCH_SHARED_REGISTER_BASE;
       // ... и т.д.
   }
   ```

   ДЕЙСТВИЕ:
   - ОСТАВИТЬ ОБА блока (if и else)
   - ОБНОВИТЬ комментарии:
     - if блок: "// PCH based platforms (Gen 6+: Sandy Bridge, Ivy Bridge, Haswell, Broadwell, Skylake, etc.)"
     - else блок: "// SoC platforms WITHOUT PCH (Gen 6+: ValleyView, CherryView, Apollo Lake, Gemini Lake, etc.)"

3.4. ValleyView display offset (строки ~310):
   ```cpp
   if (info.device_type.InGroup(INTEL_GROUP_VLV)) {
       blocks[REGISTER_BLOCK(REGS_SOUTH_SHARED)] += VLV_DISPLAY_BASE;
       blocks[REGISTER_BLOCK(REGS_SOUTH_TRANSCODER_PORT)] += VLV_DISPLAY_BASE;
   }
   ```
   ОСТАВИТЬ КАК ЕСТЬ - это специфика ValleyView SoC


ЗАДАЧА 4: ACCELERANT.CPP - БАЗОВАЯ ЛОГИКА
------------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/accelerant.cpp

4.1. Функция init_common() - ОСТАВИТЬ БЕЗ ИЗМЕНЕНИЙ
   Комментарий "Gen 6+: No 3D context allocation needed" корректен

4.2. Функция intel_get_accelerant_device_info() - ОСТАВИТЬ
   Комментарий "Gen 6+ naming" корректен


ЗАДАЧА 5: MODE.CPP - УПРАВЛЕНИЕ РЕЖИМАМИ
-----------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/mode.cpp

5.1. Функция get_color_space_format() - ОСТАВИТЬ БЕЗ ИЗМЕНЕНИЙ

5.2. Функция set_frame_buffer_registers() (строки ~110-140):
   КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ:

   БЫЛО:
   ```cpp
   if (sharedInfo.device_type.InFamily(INTEL_FAMILY_SER5)
       || sharedInfo.device_type.InFamily(INTEL_FAMILY_LAKE)
       || sharedInfo.device_type.InFamily(INTEL_FAMILY_SOC0)) {
       // ... код для Gen 6+ ...
   } else {
       // Старый код для Gen < 6
       write32(INTEL_DISPLAY_A_BASE + offset, ...);
   }
   ```

   СТАЛО:
   ```cpp
   // Gen 6+ display offset handling
   // All supported GPUs should fall into this category
   if (sharedInfo.device_type.InFamily(INTEL_FAMILY_SER5)
       || sharedInfo.device_type.InFamily(INTEL_FAMILY_LAKE)
       || sharedInfo.device_type.InFamily(INTEL_FAMILY_SOC0)) {
       if (sharedInfo.device_type.InGroup(INTEL_GROUP_HAS)) {
           write32(INTEL_DISPLAY_A_OFFSET_HAS + offset,
               ((uint32)mode.v_display_start << 16)
                   | (uint32)mode.h_display_start);
           read32(INTEL_DISPLAY_A_OFFSET_HAS + offset);
       } else {
           write32(INTEL_DISPLAY_A_BASE + offset,
               mode.v_display_start * sharedInfo.bytes_per_row
               + mode.h_display_start * bytes_per_pixel);
           read32(INTEL_DISPLAY_A_BASE + offset);
       }
       write32(INTEL_DISPLAY_A_SURFACE + offset, sharedInfo.frame_buffer_offset);
       read32(INTEL_DISPLAY_A_SURFACE + offset);
   } else {
       // This should never happen on Gen 6+ hardware
       ERROR("%s: Unsupported device family for framebuffer setup! "
           "Device type: 0x%x\n", __func__, sharedInfo.device_type.type);
   }
   ```

5.3. Функция limit_modes_for_gen3_lvds() - УДАЛИТЬ:
   ```cpp
   // УДАЛИТЬ эту функцию полностью
   static bool
   limit_modes_for_gen3_lvds(display_mode* mode)
   {
       ...
   }
   ```

5.4. Функция create_mode_list() (строки ~170-250):
   БЫЛО:
   ```cpp
   if (gInfo->shared_info->device_type.Generation() >= 4) {
       supportedSpaces = kSupportedSpaces;
       colorSpaceCount = B_COUNT_OF(kSupportedSpaces);
   } else {
       supportedSpaces = NULL;
       colorSpaceCount = 0;
   }
   ```

   СТАЛО:
   ```cpp
   // Gen 6+ doesn't support B_RGB15, use custom colorspace list
   supportedSpaces = kSupportedSpaces;
   colorSpaceCount = B_COUNT_OF(kSupportedSpaces);
   ```

   И УДАЛИТЬ:
   ```cpp
   // УДАЛИТЬ эту проверку и вызов
   check_display_mode_hook limitModes = NULL;
   if (gInfo->shared_info->device_type.Generation() < 4)
       limitModes = limit_modes_for_gen3_lvds;
   ```


ЗАДАЧА 6: PLL.CPP - PLL АЛГОРИТМЫ
----------------------------------

Файл: src/add-ons/accelerants/intel_extreme/pll.cpp

6.1. Комментарии в начале файла - ОСТАВИТЬ:
   "Gen 6+ uses completely different PLL algorithms" - корректен

6.2. Функция refclk_activate_ilk():
   - Проверяет pch_info == INTEL_PCH_IBX (это IronLake - Gen 5!)
   - АНАЛИЗ: Функция используется для настройки reference clock на Gen 6+
   - ДЕЙСТВИЕ: ОСТАВИТЬ функцию, но ОБНОВИТЬ комментарий:

   БЫЛО:
   ```cpp
   if (gInfo->shared_info->pch_info == INTEL_PCH_IBX) {
       TRACE("%s: Generation 5 graphics\n", __func__);
       ...
   }
   ```

   СТАЛО:
   ```cpp
   if (gInfo->shared_info->pch_info == INTEL_PCH_IBX) {
       TRACE("%s: Ibex Peak PCH (first PCH for Gen 6 Sandy Bridge)\n", __func__);
       ...
   }
   ```


ЗАДАЧА 7: HOOKS.CPP - OVERLAY ПОДДЕРЖКА
----------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/hooks.cpp

7.1. Overlay hooks (строки ~167):
   ```cpp
   case B_ALLOCATE_OVERLAY_BUFFER:
       // TODO: overlay doesn't seem to work on these chips (Gen 6+)
       if (gInfo->shared_info->device_type.InFamily(INTEL_FAMILY_SER5)
           || gInfo->shared_info->device_type.InFamily(INTEL_FAMILY_SOC0))
           return NULL;
       return (void*)intel_allocate_overlay_buffer;
   ```
   ОСТАВИТЬ КАК ЕСТЬ - это известная проблема


ЗАДАЧА 8: OVERLAY.CPP - OVERLAY ФУНКЦИИ
----------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/overlay.cpp

8.1. Функция intel_overlay_supported_spaces() - ОСТАВИТЬ

8.2. Функция intel_allocate_overlay_buffer():
   - Ищет проверки: IsModel(INTEL_MODEL_965)
   - INTEL_MODEL_965 это Gen 4 (i965)
   - ДЕЙСТВИЕ: УДАЛИТЬ весь код связанный с INTEL_MODEL_965


ЗАДАЧА 9: ENGINE.CPP - 2D УСКОРЕНИЕ
------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/engine.cpp

9.1. Функция intel_wait_engine_idle():
   ```cpp
   // Skylake acc engine not yet functional (stalls)
   if (gInfo->shared_info->device_type.InFamily(INTEL_FAMILY_LAKE)
           || gInfo->shared_info->device_type.InFamily(INTEL_FAMILY_SOC0)) {
       return;
   }
   ```
   ОСТАВИТЬ КАК ЕСТЬ - это временный workaround


ЗАДАЧА 10: PIPES.CPP - УПРАВЛЕНИЕ PIPES
----------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/Pipes.cpp

10.1. Конструктор Pipe::Pipe():
   - Комментарий "Program gen5(+) style panelfitter"
   - ЗАМЕНИТЬ НА: "// Program Gen 6+ style panelfitter"

10.2. Функция Pipe::Configure():
   БЫЛО:
   ```cpp
   if (gInfo->shared_info->device_type.Generation() >= 6) {
       // According to SandyBridge modesetting sequence...
       // ... код ...
   }
   ```

   СТАЛО:
   ```cpp
   // According to SandyBridge modesetting sequence, pipe must be enabled
   // before PLL are configured. (Applies to all Gen 6+ hardware)
   // ... код без if блока ...
   ```

10.3. Функция Pipe::ConfigureScalePos():
   БЫЛО:
   ```cpp
   if ((gInfo->shared_info->device_type.Generation() <= 4)
       || gInfo->shared_info->device_type.HasDDI()) {
       write32(INTEL_DISPLAY_A_IMAGE_SIZE + fPipeOffset, ...);
   }
   ```

   СТАЛО:
   ```cpp
   // Required for DDI platforms (Gen 6+: Haswell and newer)
   if (gInfo->shared_info->device_type.HasDDI()) {
       write32(INTEL_DISPLAY_A_IMAGE_SIZE + fPipeOffset,
           ((uint32)(target->timing.v_display - 1) << 16)
           | ((uint32)target->timing.h_display - 1));
   }
   ```


ЗАДАЧА 11: PORTS.CPP - УПРАВЛЕНИЕ ПОРТАМИ
------------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/Ports.cpp

11.1. Функция Port::SetupI2c():
   БЫЛО:
   ```cpp
   if (gInfo->shared_info->device_type.Generation() >= 6 && deviceConfigCount > 0) {
   ```

   СТАЛО:
   ```cpp
   // Gen 6+ uses VBT for port configuration
   if (deviceConfigCount > 0) {
   ```

11.2. Функция Port::IsConnected():
   То же изменение - убрать проверку Generation() >= 6

11.3. Функция DisplayPort::PipePreference():
   БЫЛО:
   ```cpp
   if (gInfo->shared_info->device_type.Generation() <= 4)
       return INTEL_PIPE_ANY;
   ```

   ДЕЙСТВИЕ: УДАЛИТЬ эту проверку, она никогда не выполнится для Gen 6+

11.4. Функция Port::_DDCPin() - имеет else блок в конце:
   ПРОВЕРИТЬ: если else содержит switch для старых генераций - УДАЛИТЬ
   ОСТАВИТЬ: если else для Gen 6+ SoC чипов

11.5. HDMIPort::_PortRegister():
   ```cpp
   bool fourthGen = gInfo->shared_info->device_type.InGroup(INTEL_GROUP_VLV);
   ```

   КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ:
   - Переменная называется "fourthGen" но это НЕПРАВИЛЬНО!
   - INTEL_GROUP_VLV это ValleyView - Gen 7!
   - ДЕЙСТВИЕ: ПЕРЕИМЕНОВАТЬ переменную:

   БЫЛО:
   ```cpp
   bool fourthGen = gInfo->shared_info->device_type.InGroup(INTEL_GROUP_VLV);
   ```

   СТАЛО:
   ```cpp
   // ValleyView is Gen 7 SoC with special port registers
   bool isValleyView = gInfo->shared_info->device_type.InGroup(INTEL_GROUP_VLV);
   ```

   И заменить все использования fourthGen на isValleyView


ЗАДАЧА 12: FLEXIBLEDISPLAYINTERFACE.CPP - FDI
----------------------------------------------

Файл: src/add-ons/accelerants/intel_extreme/FlexibleDisplayInterface.cpp

12.1. Функции FDI Train - ОСТАВИТЬ БЕЗ ИЗМЕНЕНИЙ
   Код корректен для Gen 6+ с PCH


ЗАДАЧА 13: POWER.CPP - УПРАВЛЕНИЕ ПИТАНИЕМ
-------------------------------------------

Файл: src/add-ons/kernel/drivers/graphics/intel_extreme/power.cpp

13.1. Функция intel_en_gating() - ОСТАВИТЬ БЕЗ ИЗМЕНЕНИЙ
   Комментарий "Gen 6+ clock gating" корректен

13.2. Функция intel_en_downclock() - ОСТАВИТЬ БЕЗ ИЗМЕНЕНИЙ
   Код корректен для Gen 6+


====================================================================
ДОПОЛНИТЕЛЬНЫЕ ПРОВЕРКИ
====================================================================

ГЛОБАЛЬНЫЙ ПОИСК ПО ПРОЕКТУ:

1. Поиск: "Generation\(\).*<.*[345]"
   - Удалить или заменить логику

2. Поиск: "Generation\(\).*<=.*[345]"
   - Удалить или заменить логику

3. Поиск: "Generation\(\).*==.*[2345]"
   - Удалить код для этих генераций

4. Поиск: "INTEL_GROUP_G4x"
   - Если существует - УДАЛИТЬ

5. Поиск комментариев: "gen[2345]", "Gen [2-5]", "i965"
   - Обновить комментарии

6. Поиск: "i8xx", "i9xx", "gen3", "gen4", "gen5" в комментариях
   - Обновить или удалить

7. Поиск: "INTEL_MODEL_965"
   - УДАЛИТЬ определение и все использования


====================================================================
ВАЖНЫЕ ЗАМЕЧАНИЯ ДЛЯ РЕФАКТОРИНГА
====================================================================

⚠️ КРИТИЧЕСКИЕ ОГРАНИЧЕНИЯ:

1. **НЕ УДАЛЯТЬ MCH/ICH регистры!**
   Они нужны для SoC платформ (ValleyView, CherryView, Apollo Lake, etc.)

2. **Не менять логику register blocks setup**
   Код корректно различает PCH и non-PCH платформы

3. **ValleyView/CherryView это Gen 7-8, но SoC!**
   Не путать с обычными Gen 7-8 с PCH (Ivy Bridge, Haswell)

4. **fourthGen переменная неправильно названа**
   Она проверяет ValleyView (Gen 7), не Gen 4

5. **Сохранять API/ABI совместимость**
   - НЕ изменять публичные структуры
   - НЕ менять размеры структур shared_info
   - НЕ удалять функции из публичного API

6. **Apollo Lake / Gemini Lake**
   - Это Gen 9 SoC без PCH
   - Используют Gen9 LP graphics
   - Модель INTEL_MODEL_KBYM

====================================================================
ПЛАН ВЫПОЛНЕНИЯ
====================================================================

ЭТАП 1: ПОДГОТОВКА
-------------------
1. Создать ветку: git checkout -b refactor-remove-gen-lt-6
2. Создать backup
3. Собрать текущую версию для тестирования

ЭТАП 2: ВЫПОЛНЕНИЕ ЗАДАЧ (по порядку)
--------------------------------------
1. ЗАДАЧА 1: Header файлы
2. ЗАДАЧА 2: Driver.cpp
3. ЗАДАЧА 3: Intel_extreme.cpp (ОСТОРОЖНО с register blocks!)
4. ЗАДАЧА 4: Accelerant.cpp
5. ЗАДАЧА 5: Mode.cpp
6. ЗАДАЧА 6: Pll.cpp
7. ЗАДАЧА 7-8: Hooks.cpp, Overlay.cpp
8. ЗАДАЧА 9: Engine.cpp
9. ЗАДАЧА 10: Pipes.cpp
10. ЗАДАЧА 11: Ports.cpp (переименовать fourthGen!)
11. ЗАДАЧА 12: FlexibleDisplayInterface.cpp
12. ЗАДАЧА 13: Power.cpp

ЭТАП 3: ГЛОБАЛЬНАЯ ОЧИСТКА
---------------------------
1. Выполнить все проверки из "ДОПОЛНИТЕЛЬНЫЕ ПРОВЕРКИ"
2. Удалить INTEL_MODEL_965 и подобные старые модели
3. Обновить комментарии
4. Проверить на dead code

ЭТАП 4: КОМПИЛЯЦИЯ И ТЕСТИРОВАНИЕ
----------------------------------
1. Собрать драйвер
2. Проверить warnings
3. Тестировать на Gen 6+ hardware
4. Проверить что драйвер отказывает Gen < 6

====================================================================
ПРИМЕРЫ КОНКРЕТНЫХ ИЗМЕНЕНИЙ
====================================================================

ПРИМЕР 1: НЕ УДАЛЯТЬ register blocks (intel_extreme.cpp)
---------------------------------------------------------

НЕПРАВИЛЬНО:
```cpp
// ❌ НЕ ДЕЛАТЬ ТАК!
if (hasPCH) {
    blocks[REGISTER_BLOCK(REGS_NORTH_SHARED)] = PCH_NORTH_SHARED_REGISTER_BASE;
    // ...
}
// Удалили else блок - ОШИБКА!
```

ПРАВИЛЬНО:
```cpp
// ✅ ПРАВИЛЬНО:
if (hasPCH) {
    // PCH based platforms (Gen 6+: Sandy Bridge, Ivy Bridge, Haswell, etc.)
    blocks[REGISTER_BLOCK(REGS_NORTH_SHARED)] = PCH_NORTH_SHARED_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_NORTH_PIPE_AND_PORT)] = PCH_NORTH_PIPE_AND_PORT_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_NORTH_PLANE_CONTROL)] = PCH_NORTH_PLANE_CONTROL_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_SOUTH_SHARED)] = PCH_SOUTH_SHARED_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_SOUTH_TRANSCODER_PORT)] = PCH_SOUTH_TRANSCODER_AND_PORT_REGISTER_BASE;
} else {
    // SoC platforms WITHOUT PCH (Gen 6+: ValleyView, CherryView, Apollo Lake, Gemini Lake)
    blocks[REGISTER_BLOCK(REGS_NORTH_SHARED)] = MCH_SHARED_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_NORTH_PIPE_AND_PORT)] = MCH_PIPE_AND_PORT_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_NORTH_PLANE_CONTROL)] = MCH_PLANE_CONTROL_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_SOUTH_SHARED)] = ICH_SHARED_REGISTER_BASE;
    blocks[REGISTER_BLOCK(REGS_SOUTH_TRANSCODER_PORT)] = ICH_PORT_REGISTER_BASE;
}

// ValleyView needs special display base offset
if (info.device_type.InGroup(INTEL_GROUP_VLV)) {
    blocks[REGISTER_BLOCK(REGS_SOUTH_SHARED)] += VLV_DISPLAY_BASE;
    blocks[REGISTER_BLOCK(REGS_SOUTH_TRANSCODER_PORT)] += VLV_DISPLAY_BASE;
}
```

ПРИМЕР 2: Переименование fourthGen (Ports.cpp)
-----------------------------------------------

БЫЛО:
```cpp
addr_t
HDMIPort::_PortRegister()
{
    bool hasPCH = (gInfo->shared_info->pch_info != INTEL_PCH_NONE);
    bool fourthGen = gInfo->shared_info->device_type.InGroup(INTEL_GROUP_VLV);

    switch (PortIndex()) {
        case INTEL_PORT_B:
            if (fourthGen)
                return GEN4_HDMI_PORT_B;
            return hasPCH ? PCH_HDMI_PORT_B : INTEL_HDMI_PORT_B;
        case INTEL_PORT_C:
            if (fourthGen)
                return GEN4_HDMI_PORT_C;
            return hasPCH ? PCH_HDMI_PORT_C : INTEL_HDMI_PORT_C;
        // ...
    }
}
```

СТАЛО:
```cpp
addr_t
HDMIPort::_PortRegister()
{
    bool hasPCH = (gInfo->shared_info->pch_info != INTEL_PCH_NONE);
    // ValleyView is Gen 7 SoC with special HDMI port registers
    bool isValleyView = gInfo->shared_info->device_type.InGroup(INTEL_GROUP_VLV);

    switch (PortIndex()) {
        case INTEL_PORT_B:
            if (isValleyView)
                return GEN4_HDMI_PORT_B;  // Note: GEN4 name is misleading, these are VLV regs
            return hasPCH ? PCH_HDMI_PORT_B : INTEL_HDMI_PORT_B;
        case INTEL_PORT_C:
            if (isValleyView)
                return GEN4_HDMI_PORT_C;  // Note: GEN4 name is misleading, these are VLV regs
            return hasPCH ? PCH_HDMI_PORT_C : INTEL_HDMI_PORT_C;
        case INTEL_PORT_D:
            if (gInfo->shared_info->device_type.InGroup(INTEL_GROUP_CHV))
                return CHV_HDMI_PORT_D;
            return hasPCH ? PCH_HDMI_PORT_D : 0;
        default:
            return 0;
    }
}
```

ПРИМЕР 3: Удаление limit_modes_for_gen3_lvds (mode.cpp)
--------------------------------------------------------

УДАЛИТЬ полностью:
```cpp
// ❌ УДАЛИТЬ ЭТУ ФУНКЦИЮ
static bool
limit_modes_for_gen3_lvds(display_mode* mode)
{
    if (gInfo->shared_info->panel_timing.h_display < mode->timing.h_display)
        return false;
    if (gInfo->shared_info->panel_timing.v_display < mode->timing.v_display)
        return false;
    return true;
}
```

И в create_mode_list():
```cpp
// ❌ УДАЛИТЬ:
check_display_mode_hook limitModes = NULL;
if (gInfo->shared_info->device_type.Generation() < 4)
    limitModes = limit_modes_for_gen3_lvds;
```

ПРИМЕР 4: Упрощение color space selection (mode.cpp)
-----------------------------------------------------

БЫЛО:
```cpp
const color_space kSupportedSpaces[] = {B_RGB32_LITTLE, B_RGB16_LITTLE, B_CMAP8};
const color_space* supportedSpaces;
int colorSpaceCount;

if (gInfo->shared_info->device_type.Generation() >= 4) {
    supportedSpaces = kSupportedSpaces;
    colorSpaceCount = B_COUNT_OF(kSupportedSpaces);
} else {
    supportedSpaces = NULL;
    colorSpaceCount = 0;
}
```

СТАЛО:
```cpp
// Gen 6+ doesn't support B_RGB15, use custom colorspace list
const color_space kSupportedSpaces[] = {B_RGB32_LITTLE, B_RGB16_LITTLE, B_CMAP8};
const color_space* supportedSpaces = kSupportedSpaces;
int colorSpaceCount = B_COUNT_OF(kSupportedSpaces);
```

====================================================================
КОНТРОЛЬНЫЙ СПИСОК ФИНАЛЬНОЙ ПРОВЕРКИ
====================================================================

□ Все упоминания Gen 2, 3, 4, 5 удалены из кода (кроме комментариев о минимальных требованиях)
□ Функция limit_modes_for_gen3_lvds() удалена
□ Все проверки Generation() < 6 удалены (кроме intel_extreme.cpp:init)
□ Все проверки Generation() <= 5 удалены
□ Все проверки Generation() == [2-5] удалены
□ INTEL_MODEL_965 удален
□ **MCH/ICH register blocks НЕ УДАЛЕНЫ** (нужны для SoC!)
□ **Register blocks setup оставлен с if/else** (нужен для PCH vs SoC)
□ fourthGen переименован в isValleyView
□ Комментарии обновлены и точны
□ Код компилируется без ошибок
□ Код компилируется без warnings
□ Драйвер корректно работает на Gen 6+ PCH hardware
□ Драйвер корректно работает на Gen 6+ SoC hardware (ValleyView, Apollo Lake)
□ Драйвер корректно отказывает на Gen < 6 hardware

====================================================================
ВАЖНАЯ ИНФОРМАЦИЯ ПРО АРХИТЕКТУРУ INTEL GPU
====================================================================

Gen 6+ РАЗДЕЛЯЕТСЯ НА ДВА ТИПА:

1. **С PCH (Platform Controller Hub)**:
   - Sandy Bridge (Gen 6) - PCH_IBX
   - Ivy Bridge (Gen 7) - PCH_CPT/PPT
   - Haswell (Gen 7) - PCH_LPT/WPT
   - Broadwell (Gen 8) - PCH_LPT
   - Skylake+ (Gen 9+) - PCH_SPT/CNP/ICP/TGP/etc.

2. **SoC БЕЗ PCH (System-on-Chip)**:
   - ValleyView/Bay Trail (Gen 7) - INTEL_PCH_NONE
   - CherryView/Braswell (Gen 8) - INTEL_PCH_NONE
   - Apollo Lake (Gen 9) - INTEL_PCH_NONE или специфический PCH
   - Gemini Lake (Gen 9) - INTEL_PCH_CNP или INTEL_PCH_NONE
   - JasperLake (Gen 11) - INTEL_PCH_JSP

SoC чипы используют MCH/ICH register layout, а не PCH layout!

====================================================================
КОНЕЦ ИСПРАВЛЕННОЙ ИНСТРУКЦИИ
====================================================================
