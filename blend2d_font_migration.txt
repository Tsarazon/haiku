# Инструкция по миграции с AGG на blend2d в Haiku Font Rendering

## Обзор изменений

Заменяем AGG (Anti-Grain Geometry) на blend2d с сохранением публичных API.
Ключевое изменение: субпиксельный рендеринг заменяется на **перцептивно-взвешенный alpha**.

### Затрагиваемые файлы

1. `src/servers/app/font/FontEngine.h` - **сохраняем имя класса**, меняем реализацию
2. `src/servers/app/font/FontEngine.cpp` - полная переработка
3. `src/servers/app/drawing/Painter/AGGTextRenderer.h` → `Blend2dTextRenderer.h`
4. `src/servers/app/drawing/Painter/AGGTextRenderer.cpp` → `Blend2dTextRenderer.cpp`
5. `src/servers/app/font/FontCacheEntry.h` - адаптация под blend2d
6. `src/servers/app/font/FontCacheEntry.cpp` - адаптация под blend2d

---

## Шаг 1: Модификация FontEngine.h

**Файл:** `src/servers/app/font/FontEngine.h`

**Что делаем:** Заменяем AGG типы на blend2d, **сохраняя имя класса FontEngine**.

```cpp
/*
 * Copyright 2007, Haiku. All rights reserved.
 * Distributed under the terms of the MIT License.
 *
 * Authors:
 *		Maxim Shemanarev <mcseemagg@yahoo.com>
 *		Stephan Aßmus <superstippi@gmx.de>
 *		Andrej Spielmann, <andrej.spielmann@seh.ox.ac.uk>
 */

#ifndef FONT_ENGINE_H
#define FONT_ENGINE_H

#include <SupportDefs.h>

#include <ft2build.h>
#include FT_FREETYPE_H

#include <blend2d.h>

enum glyph_rendering {
	glyph_ren_native_mono,
	glyph_ren_native_gray8,
	glyph_ren_outline,
	glyph_ren_lcd  // заменяет glyph_ren_subpix
};

enum glyph_data_type {
	glyph_data_invalid	= 0,
	glyph_data_mono		= 1,
	glyph_data_gray8	= 2,
	glyph_data_outline	= 3,
	glyph_data_lcd		= 4  // заменяет glyph_data_subpix
};

class FontEngine {
 public:
	// Адаптеры для совместимости с существующим кодом
	typedef BLPath							PathAdapter;
	
								FontEngine();
	virtual						~FontEngine();

			bool				Init(const char* fontFilePath,
									unsigned face_index, double size,
									FT_Encoding char_map,
									glyph_rendering ren_type,
									bool hinting,
									const void* fontFileBuffer = NULL,
									const long fontFileBufferSize = 0);

			int					LastError() const
									{ return fLastError; }
			unsigned			CountFaces() const;
			bool				Hinting() const
									{ return fHinting; }

			uint32				GlyphIndexForGlyphCode(uint32 glyphCode) const;
			bool				PrepareGlyph(uint32 glyphIndex);

			uint32				DataSize() const;
			glyph_data_type		DataType() const
									{ return fDataType; }
			BLBox				Bounds() const
									{ return fBounds; }
			double				AdvanceX() const
									{ return fAdvanceX; }
			double				AdvanceY() const
									{ return fAdvanceY; }
			double				PreciseAdvanceX() const
									{ return fPreciseAdvanceX; }
			double				PreciseAdvanceY() const
									{ return fPreciseAdvanceY; }
			double				InsetLeft() const
									{ return fInsetLeft; }
			double				InsetRight() const
									{ return fInsetRight; }

			void				WriteGlyphTo(uint8* data) const;
			bool				GetKerning(uint32 first, uint32 second,
									double* x, double* y);

			// Методы для получения данных глифов
			const BLPath&		Path() const { return fPath; }
			const BLImage&		Image() const { return fImage; }

 private:
			// disallowed stuff:
								FontEngine(const FontEngine&);
			const FontEngine&	operator=(const FontEngine&);

			int					fLastError;
			bool				fLibraryInitialized;
			FT_Library			fLibrary;
			FT_Face				fFace;

			glyph_rendering		fGlyphRendering;
			bool				fHinting;

			// Данные глифа
			glyph_data_type		fDataType;
			BLBox				fBounds;
			double				fAdvanceX;
			double				fAdvanceY;
			double				fPreciseAdvanceX;
			double				fPreciseAdvanceY;
			double				fInsetLeft;
			double				fInsetRight;

			// blend2d структуры для хранения данных глифа
			BLPath				fPath;			// для векторных глифов
			BLImage				fImage;			// для растровых глифов
};

#endif // FONT_ENGINE_H
```

---

## Шаг 2: Реализация FontEngine.cpp

**Файл:** `src/servers/app/font/FontEngine.cpp`

**Ключевые функции:**
1. `decompose_ft_outline_to_blend2d()` - конвертация FT_Outline → BLPath
2. `convert_ft_bitmap_lcd_to_alpha()` - **перцептивный alpha из LCD RGB**
3. `PrepareGlyph()` - подготовка данных глифа

```cpp
/*
 * Copyright 2007, Haiku. All rights reserved.
 * Distributed under the terms of the MIT License.
 */

#include "FontEngine.h"

#include FT_GLYPH_H
#include FT_OUTLINE_H

#include <stdio.h>

static const bool kFlipY = true;

// ============================================================================
// Вспомогательные функции конвертации
// ============================================================================

static inline double
int26p6_to_dbl(int p)
{
	return double(p) / 64.0;
}

static inline int
dbl_to_int26p6(double p)
{
	return int(p * 64.0 + 0.5);
}

// Конвертация FT_Outline в BLPath
static bool
decompose_ft_outline_to_blend2d(const FT_Outline& outline, bool flip_y, 
                                 BLPath& path)
{
	FT_Vector v_last;
	FT_Vector v_control;
	FT_Vector v_start;
	FT_Vector* point;
	FT_Vector* limit;
	char* tags;

	int first = 0;

	for (int n = 0; n < outline.n_contours; n++) {
		int last = outline.contours[n];
		limit = outline.points + last;

		v_start = outline.points[first];
		v_last = outline.points[last];
		v_control = v_start;

		point = outline.points + first;
		tags = outline.tags + first;
		char tag = FT_CURVE_TAG(tags[0]);

		// Контур не может начинаться с кубической контрольной точки
		if (tag == FT_CURVE_TAG_CUBIC)
			return false;

		// Проверяем первую точку
		if (tag == FT_CURVE_TAG_CONIC) {
			if (FT_CURVE_TAG(outline.tags[last]) == FT_CURVE_TAG_ON) {
				v_start = v_last;
				limit--;
			} else {
				v_start.x = (v_start.x + v_last.x) / 2;
				v_start.y = (v_start.y + v_last.y) / 2;
				v_last = v_start;
			}
			point--;
			tags--;
		}

		double x = int26p6_to_dbl(v_start.x);
		double y = int26p6_to_dbl(v_start.y);
		if (flip_y) y = -y;
		path.moveTo(x, y);

		while (point < limit) {
			point++;
			tags++;
			tag = FT_CURVE_TAG(tags[0]);

			switch(tag) {
				case FT_CURVE_TAG_ON: {
					x = int26p6_to_dbl(point->x);
					y = int26p6_to_dbl(point->y);
					if (flip_y) y = -y;
					path.lineTo(x, y);
					continue;
				}

				case FT_CURVE_TAG_CONIC: {
					v_control.x = point->x;
					v_control.y = point->y;

				Do_Conic:
					if (point < limit) {
						FT_Vector vec;
						FT_Vector v_middle;

						point++;
						tags++;
						tag = FT_CURVE_TAG(tags[0]);

						vec.x = point->x;
						vec.y = point->y;

						if (tag == FT_CURVE_TAG_ON) {
							double x1 = int26p6_to_dbl(v_control.x);
							double y1 = int26p6_to_dbl(v_control.y);
							double x2 = int26p6_to_dbl(vec.x);
							double y2 = int26p6_to_dbl(vec.y);
							if (flip_y) { y1 = -y1; y2 = -y2; }
							path.quadTo(x1, y1, x2, y2);
							continue;
						}

						if (tag != FT_CURVE_TAG_CONIC)
							return false;

						v_middle.x = (v_control.x + vec.x) / 2;
						v_middle.y = (v_control.y + vec.y) / 2;

						double x1 = int26p6_to_dbl(v_control.x);
						double y1 = int26p6_to_dbl(v_control.y);
						double x2 = int26p6_to_dbl(v_middle.x);
						double y2 = int26p6_to_dbl(v_middle.y);
						if (flip_y) { y1 = -y1; y2 = -y2; }
						path.quadTo(x1, y1, x2, y2);

						v_control = vec;
						goto Do_Conic;
					}

					double x1 = int26p6_to_dbl(v_control.x);
					double y1 = int26p6_to_dbl(v_control.y);
					double x2 = int26p6_to_dbl(v_start.x);
					double y2 = int26p6_to_dbl(v_start.y);
					if (flip_y) { y1 = -y1; y2 = -y2; }
					path.quadTo(x1, y1, x2, y2);
					goto Close;
				}

				default: { // FT_CURVE_TAG_CUBIC
					FT_Vector vec1, vec2;

					if (point + 1 > limit || FT_CURVE_TAG(tags[1]) != FT_CURVE_TAG_CUBIC)
						return false;

					vec1.x = point[0].x;
					vec1.y = point[0].y;
					vec2.x = point[1].x;
					vec2.y = point[1].y;

					point += 2;
					tags += 2;

					if (point <= limit) {
						FT_Vector vec;
						vec.x = point->x;
						vec.y = point->y;

						double x1 = int26p6_to_dbl(vec1.x);
						double y1 = int26p6_to_dbl(vec1.y);
						double x2 = int26p6_to_dbl(vec2.x);
						double y2 = int26p6_to_dbl(vec2.y);
						double x3 = int26p6_to_dbl(vec.x);
						double y3 = int26p6_to_dbl(vec.y);
						if (flip_y) { y1 = -y1; y2 = -y2; y3 = -y3; }
						path.cubicTo(x1, y1, x2, y2, x3, y3);
						continue;
					}

					double x1 = int26p6_to_dbl(vec1.x);
					double y1 = int26p6_to_dbl(vec1.y);
					double x2 = int26p6_to_dbl(vec2.x);
					double y2 = int26p6_to_dbl(vec2.y);
					double x3 = int26p6_to_dbl(v_start.x);
					double y3 = int26p6_to_dbl(v_start.y);
					if (flip_y) { y1 = -y1; y2 = -y2; y3 = -y3; }
					path.cubicTo(x1, y1, x2, y2, x3, y3);
					goto Close;
				}
			}
		}

		path.close();
	Close:
		first = last + 1;
	}

	return true;
}

// Конвертация FT_Bitmap в BLImage
// ВАЖНО: для LCD (субпиксельного) используем перцептивный alpha
static BLImage
convert_ft_bitmap_to_blend2d(const FT_Bitmap& bitmap, bool flip_y, 
                              glyph_data_type dataType)
{
	BLImage image;

	if (bitmap.pixel_mode == FT_PIXEL_MODE_MONO) {
		// Монохромный bitmap - 1 бит на пиксель
		if (image.create(bitmap.width, bitmap.rows, BL_FORMAT_A8) != BL_SUCCESS)
			return image;

		BLImageData imageData;
		if (image.getData(&imageData) != BL_SUCCESS)
			return BLImage();

		uint8_t* dst = static_cast<uint8_t*>(imageData.pixelData);
		intptr_t dstStride = imageData.stride;

		const uint8_t* src = bitmap.buffer;
		int srcPitch = bitmap.pitch;

		if (flip_y) {
			src += srcPitch * (bitmap.rows - 1);
			srcPitch = -srcPitch;
		}

		for (unsigned int y = 0; y < bitmap.rows; y++) {
			uint8_t* dstRow = dst + y * dstStride;
			const uint8_t* srcRow = src + y * srcPitch;

			for (unsigned int x = 0; x < bitmap.width; x++) {
				uint8_t byte = srcRow[x / 8];
				uint8_t bit = (byte >> (7 - (x % 8))) & 1;
				dstRow[x] = bit ? 255 : 0;
			}
		}

	} else if (bitmap.pixel_mode == FT_PIXEL_MODE_GRAY) {
		// Grayscale bitmap
		if (image.create(bitmap.width, bitmap.rows, BL_FORMAT_A8) != BL_SUCCESS)
			return image;

		BLImageData imageData;
		if (image.getData(&imageData) != BL_SUCCESS)
			return BLImage();

		uint8_t* dst = static_cast<uint8_t*>(imageData.pixelData);
		intptr_t dstStride = imageData.stride;

		const uint8_t* src = bitmap.buffer;
		int srcPitch = bitmap.pitch;

		if (flip_y) {
			src += srcPitch * (bitmap.rows - 1);
			srcPitch = -srcPitch;
		}

		for (unsigned int y = 0; y < bitmap.rows; y++) {
			memcpy(dst + y * dstStride, src + y * srcPitch, bitmap.width);
		}

	} else if (bitmap.pixel_mode == FT_PIXEL_MODE_LCD) {
		// LCD bitmap - RGB субпиксели
		// КРИТИЧНО: Конвертируем в перцептивно-взвешенный alpha
		// Формула: alpha = 0.299*R + 0.587*G + 0.114*B
		
		unsigned int width = bitmap.width / 3;
		if (image.create(width, bitmap.rows, BL_FORMAT_A8) != BL_SUCCESS)
			return image;

		BLImageData imageData;
		if (image.getData(&imageData) != BL_SUCCESS)
			return BLImage();

		uint8_t* dst = static_cast<uint8_t*>(imageData.pixelData);
		intptr_t dstStride = imageData.stride;

		const uint8_t* src = bitmap.buffer;
		int srcPitch = bitmap.pitch;

		if (flip_y) {
			src += srcPitch * (bitmap.rows - 1);
			srcPitch = -srcPitch;
		}

		for (unsigned int y = 0; y < bitmap.rows; y++) {
			const uint8_t* srcRow = src + y * srcPitch;
			uint8_t* dstRow = dst + y * dstStride;

			for (unsigned int x = 0; x < width; x++) {
				uint8_t r = srcRow[x * 3 + 0];
				uint8_t g = srcRow[x * 3 + 1];
				uint8_t b = srcRow[x * 3 + 2];

				// Перцептивно-взвешенный alpha (целочисленная арифметика)
				// Коэффициенты: R=0.299, G=0.587, B=0.114
				uint32_t alpha = (299 * r + 587 * g + 114 * b) / 1000;
				dstRow[x] = static_cast<uint8_t>(alpha);
			}
		}
	}

	return image;
}

// ============================================================================
// Реализация FontEngine
// ============================================================================

FontEngine::FontEngine()
	:
	fLastError(0),
	fLibraryInitialized(false),
	fLibrary(nullptr),
	fFace(nullptr),
	fGlyphRendering(glyph_ren_native_gray8),
	fHinting(true),
	fDataType(glyph_data_invalid),
	fAdvanceX(0.0),
	fAdvanceY(0.0),
	fInsetLeft(0.0),
	fInsetRight(0.0)
{
	fLastError = FT_Init_FreeType(&fLibrary);
	if (fLastError == 0)
		fLibraryInitialized = true;
}

FontEngine::~FontEngine()
{
	if (fFace)
		FT_Done_Face(fFace);

	if (fLibraryInitialized)
		FT_Done_FreeType(fLibrary);
}

unsigned
FontEngine::CountFaces() const
{
	if (fFace)
		return fFace->num_faces;
	return 0;
}

uint32
FontEngine::GlyphIndexForGlyphCode(uint32 glyphCode) const
{
	return FT_Get_Char_Index(fFace, glyphCode);
}

bool
FontEngine::PrepareGlyph(uint32 glyphIndex)
{
	FT_Int32 loadFlags = fHinting ? FT_LOAD_DEFAULT : FT_LOAD_NO_HINTING;
	if (fGlyphRendering == glyph_ren_lcd)
		loadFlags |= FT_LOAD_TARGET_LCD;
	else
		loadFlags |= FT_LOAD_TARGET_NORMAL;

	// Загружаем без хинтинга и масштаба для точных метрик
	fLastError = FT_Load_Glyph(fFace, glyphIndex,
		loadFlags | FT_LOAD_NO_HINTING | FT_LOAD_NO_SCALE);

	FT_UShort units_per_EM = fFace->units_per_EM;
	if (!FT_IS_SCALABLE(fFace))
		units_per_EM = 1;

	fPreciseAdvanceX = (double)fFace->glyph->advance.x / units_per_EM;
	fPreciseAdvanceY = (double)fFace->glyph->advance.y / units_per_EM;

	// Загружаем с хинтингом
	fLastError = FT_Load_Glyph(fFace, glyphIndex, loadFlags);
	if (fLastError != 0)
		return false;

	fAdvanceX = int26p6_to_dbl(fFace->glyph->advance.x);
	fAdvanceY = int26p6_to_dbl(fFace->glyph->advance.y);

	fInsetLeft = int26p6_to_dbl(fFace->glyph->metrics.horiBearingX);
	fInsetRight = int26p6_to_dbl(fFace->glyph->metrics.horiBearingX
		+ fFace->glyph->metrics.width - fFace->glyph->metrics.horiAdvance);

	switch(fGlyphRendering) {
		case glyph_ren_native_mono:
			fLastError = FT_Render_Glyph(fFace->glyph, FT_RENDER_MODE_MONO);
			if (fLastError == 0) {
				fImage = convert_ft_bitmap_to_blend2d(fFace->glyph->bitmap,
					kFlipY, glyph_data_mono);
				
				double left = fFace->glyph->bitmap_left;
				double top = kFlipY ? -fFace->glyph->bitmap_top : fFace->glyph->bitmap_top;
				fBounds = BLBox(left, top, 
					left + fFace->glyph->bitmap.width,
					top + fFace->glyph->bitmap.rows);
				
				fDataType = glyph_data_mono;
				return true;
			}
			break;

		case glyph_ren_native_gray8:
			fLastError = FT_Render_Glyph(fFace->glyph, FT_RENDER_MODE_NORMAL);
			if (fLastError == 0) {
				fImage = convert_ft_bitmap_to_blend2d(fFace->glyph->bitmap,
					kFlipY, glyph_data_gray8);
				
				double left = fFace->glyph->bitmap_left;
				double top = kFlipY ? -fFace->glyph->bitmap_top : fFace->glyph->bitmap_top;
				fBounds = BLBox(left, top,
					left + fFace->glyph->bitmap.width,
					top + fFace->glyph->bitmap.rows);
				
				fDataType = glyph_data_gray8;
				return true;
			}
			break;

		case glyph_ren_lcd:
			fLastError = FT_Render_Glyph(fFace->glyph, FT_RENDER_MODE_LCD);
			if (fLastError == 0) {
				// Конвертация LCD → перцептивный alpha
				fImage = convert_ft_bitmap_to_blend2d(fFace->glyph->bitmap,
					kFlipY, glyph_data_lcd);
				
				double left = fFace->glyph->bitmap_left;
				double top = kFlipY ? -fFace->glyph->bitmap_top : fFace->glyph->bitmap_top;
				fBounds = BLBox(left, top,
					left + (fFace->glyph->bitmap.width / 3),
					top + fFace->glyph->bitmap.rows);
				
				fDataType = glyph_data_lcd;
				return true;
			}
			break;

		case glyph_ren_outline:
			fPath.reset();
			if (decompose_ft_outline_to_blend2d(fFace->glyph->outline, kFlipY, fPath)) {
				BLBox box;
				fPath.getBoundingBox(&box);
				fBounds = box;
				fDataType = glyph_data_outline;
				return true;
			}
			break;
	}

	return false;
}

uint32
FontEngine::DataSize() const
{
	switch (fDataType) {
		case glyph_data_outline: {
			// Оценка размера для сериализованного пути
			size_t vertexCount = fPath.size();
			return vertexCount * sizeof(BLPoint) + 1024; // +буфер
		}
		case glyph_data_mono:
		case glyph_data_gray8:
		case glyph_data_lcd: {
			BLImageData imageData;
			if (fImage.getData(&imageData) == BL_SUCCESS)
				return imageData.stride * fImage.height();
			return 0;
		}
		default:
			return 0;
	}
}

void
FontEngine::WriteGlyphTo(uint8* data) const
{
	if (data == nullptr)
		return;

	switch (fDataType) {
		case glyph_data_outline: {
			// Сериализация BLPath
			// TODO: Реализовать собственную сериализацию или использовать
			// встроенные возможности blend2d
			break;
		}
		case glyph_data_mono:
		case glyph_data_gray8:
		case glyph_data_lcd: {
			BLImageData imageData;
			if (fImage.getData(&imageData) == BL_SUCCESS) {
				size_t dataSize = imageData.stride * fImage.height();
				memcpy(data, imageData.pixelData, dataSize);
			}
			break;
		}
		default:
			break;
	}
}

bool
FontEngine::GetKerning(uint32 first, uint32 second, double* x, double* y)
{
	if (fFace && first && second && FT_HAS_KERNING(fFace)) {
		FT_Vector delta;
		FT_Get_Kerning(fFace, first, second, FT_KERNING_DEFAULT, &delta);

		double dx = int26p6_to_dbl(delta.x);
		double dy = int26p6_to_dbl(delta.y);

		*x += dx;
		*y += dy;

		return true;
	}
	return false;
}

bool
FontEngine::Init(const char* fontFilePath, unsigned faceIndex, double size,
	FT_Encoding charMap, glyph_rendering ren_type, bool hinting,
	const void* fontFileBuffer, const long fontFileBufferSize)
{
	if (!fLibraryInitialized)
		return false;

	fHinting = hinting;
	fLastError = 0;

	if (fFace)
		FT_Done_Face(fFace);

	if (fontFileBuffer && fontFileBufferSize) {
		fLastError = FT_New_Memory_Face(fLibrary,
			(const FT_Byte*)fontFileBuffer, fontFileBufferSize,
			faceIndex, &fFace);
	} else {
		fLastError = FT_New_Face(fLibrary, fontFilePath, faceIndex, &fFace);
	}

	if (fLastError != 0)
		return false;

	switch(ren_type) {
		case glyph_ren_native_mono:
			fGlyphRendering = glyph_ren_native_mono;
			break;

		case glyph_ren_native_gray8:
			fGlyphRendering = glyph_ren_native_gray8;
			break;

		case glyph_ren_lcd:
			fGlyphRendering = glyph_ren_lcd;
			break;

		case glyph_ren_outline:
			if (FT_IS_SCALABLE(fFace))
				fGlyphRendering = glyph_ren_outline;
			else
				fGlyphRendering = glyph_ren_native_gray8;
			break;
	}

	FT_Set_Pixel_Sizes(fFace,
		unsigned(size * 64.0) >> 6,
		unsigned(size * 64.0) >> 6);

	if (charMap != FT_ENCODING_NONE) {
		fLastError = FT_Select_Charmap(fFace, charMap);
	} else {
		if (FT_Select_Charmap(fFace, FT_ENCODING_UNICODE) != 0)
			fLastError = FT_Select_Charmap(fFace, FT_ENCODING_NONE);
	}

	return fLastError == 0;
}
```

---

## Шаг 3: Создание Blend2dTextRenderer.h

**Новый файл:** `src/servers/app/drawing/Painter/Blend2dTextRenderer.h`

```cpp
/*
 * Copyright 2005-2009, Stephan Aßmus <superstippi@gmx.de>.
 * All rights reserved. Distributed under the terms of the MIT License.
 */
#ifndef BLEND2D_TEXT_RENDERER_H
#define BLEND2D_TEXT_RENDERER_H

#include <blend2d.h>

#include "FontCacheEntry.h"
#include "ServerFont.h"
#include "Transformable.h"

class FontCacheReference;

class Blend2dTextRenderer {
public:
								Blend2dTextRenderer(
									BLContext& context,
									const Transformable& transform);
	virtual						~Blend2dTextRenderer();

			void				SetFont(const ServerFont& font);
	inline	const ServerFont&	Font() const
									{ return fFont; }

			void				SetHinting(bool hinting);
			bool				Hinting() const
									{ return fHinted; }

			void				SetAntialiasing(bool antialiasing);
			bool				Antialiasing() const
									{ return fAntialias; }

			void				SetColor(const BLRgba32& color);

			BRect				RenderString(const char* utf8String,
									uint32 length, const BPoint& baseLine,
									const BRect& clippingFrame, bool dryRun,
									BPoint* nextCharPos,
									const escapement_delta* delta,
									FontCacheReference* cacheReference);

			BRect				RenderString(const char* utf8String,
									uint32 length, const BPoint* offsets,
									const BRect& clippingFrame, bool dryRun,
									BPoint* nextCharPos,
									FontCacheReference* cacheReference);

private:
	class StringRenderer;
	friend class StringRenderer;

	BLContext&					fContext;
	Transformable				fTransform;
	ServerFont					fFont;
	BLRgba32					fColor;
	bool						fHinted;
	bool						fAntialias;
};

#endif // BLEND2D_TEXT_RENDERER_H
```

---

## Шаг 4: Реализация Blend2dTextRenderer.cpp

**Новый файл:** `src/servers/app/drawing/Painter/Blend2dTextRenderer.cpp`

```cpp
/*
 * Copyright 2005-2009, Stephan Aßmus <superstippi@gmx.de>.
 * All rights reserved. Distributed under the terms of the MIT License.
 */

#include "Blend2dTextRenderer.h"

#include "GlobalSubpixelSettings.h"
#include "GlyphLayoutEngine.h"
#include "IntRect.h"

Blend2dTextRenderer::Blend2dTextRenderer(BLContext& context,
		const Transformable& transform)
	:
	fContext(context),
	fTransform(transform),
	fColor(0, 0, 0, 255),
	fHinted(true),
	fAntialias(true)
{
}

Blend2dTextRenderer::~Blend2dTextRenderer()
{
}

void
Blend2dTextRenderer::SetFont(const ServerFont& font)
{
	fFont = font;
}

void
Blend2dTextRenderer::SetHinting(bool hinting)
{
	fHinted = hinting;
}

void
Blend2dTextRenderer::SetAntialiasing(bool antialiasing)
{
	fAntialias = antialiasing;
}

void
Blend2dTextRenderer::SetColor(const BLRgba32& color)
{
	fColor = color;
}

// ============================================================================
// StringRenderer - внутренний класс для рендеринга
// ============================================================================

class Blend2dTextRenderer::StringRenderer {
public:
	StringRenderer(const IntRect& clippingFrame, bool dryRun,
			const Transformable& transform,
			const BPoint& transformOffset,
			BPoint* nextCharPos,
			Blend2dTextRenderer& renderer)
		:
		fTransform(transform),
		fTransformOffset(transformOffset),
		fClippingFrame(clippingFrame),
		fDryRun(dryRun),
		fBounds(INT32_MAX, INT32_MAX, INT32_MIN, INT32_MIN),
		fNextCharPos(nextCharPos),
		fRenderer(renderer)
	{
	}

	bool NeedsVector()
	{
		return !fTransform.IsTranslationOnly();
	}

	void Start()
	{
		// Подготовка к рендерингу
	}

	void Finish(double x, double y)
	{
		if (!fDryRun) {
			// Рисуем подчеркивание и зачеркивание если нужно
			if ((fRenderer.fFont.Face() & B_UNDERSCORE_FACE) != 0)
				_DrawHorizontalLine(y + 2);

			if ((fRenderer.fFont.Face() & B_STRIKEOUT_FACE) != 0) {
				font_height fontHeight;
				fRenderer.fFont.GetHeight(fontHeight);
				_DrawHorizontalLine(y - (fontHeight.ascent + fontHeight.descent) / 4);
			}
		}

		if (fNextCharPos) {
			fNextCharPos->x = x;
			fNextCharPos->y = y;
			fTransform.Transform(fNextCharPos);
		}
	}

	void ConsumeEmptyGlyph(int32 index, uint32 charCode, double x, double y)
	{
		// Пустой глиф - ничего не делаем
	}

	bool ConsumeGlyph(int32 index, uint32 charCode, const GlyphCache* glyph,
		FontCacheEntry* entry, double x, double y, double advanceX,
		double advanceY)
	{
		if (glyph == NULL)
			return true;

		const BLBox& r = glyph->bounds;
		IntRect glyphBounds(int32(r.x0 + x), int32(r.y0 + y - 1),
			int32(r.x1 + x + 1), int32(r.y1 + y + 1));

		// Отслеживаем границы
		fBounds = fBounds | glyphBounds;

		if (fDryRun)
			return true;

		// Трансформация позиции глифа
		double transformedX = x + fTransformOffset.x;
		double transformedY = y + fTransformOffset.y;

		if (!NeedsVector()) {
			glyphBounds.OffsetBy(fTransformOffset);
		} else {
			glyphBounds = fTransform.TransformBounds(glyphBounds);
		}

		// Проверка clipping
		if (!fClippingFrame.Intersects(glyphBounds))
			return true;

		// Рендеринг глифа
		switch (glyph->data_type) {
			case glyph_data_mono:
			case glyph_data_gray8:
			case glyph_data_lcd:
				// Растровый глиф
				_RenderBitmapGlyph(glyph, transformedX, transformedY);
				break;

			case glyph_data_outline:
				// Векторный глиф
				_RenderVectorGlyph(entry, transformedX, transformedY);
				break;

			default:
				break;
		}

		return true;
	}

	IntRect Bounds() const
	{
		return fBounds;
	}

private:
	void _RenderBitmapGlyph(const GlyphCache* glyph, double x, double y)
	{
		// TODO: Восстановить BLImage из glyph->data
		// и отрендерить через fRenderer.fContext.blitImage()
	}

	void _RenderVectorGlyph(FontCacheEntry* entry, double x, double y)
	{
		// TODO: Восстановить BLPath из данных глифа
		// и отрендерить через fRenderer.fContext.fillPath()
	}

	void _DrawHorizontalLine(float y)
	{
		IntRect bounds = fBounds;
		BPoint left(bounds.left, y);
		BPoint right(bounds.right, y);
		fTransform.Transform(&left);
		fTransform.Transform(&right);

		BLPath path;
		path.moveTo(left.x, left.y);
		path.lineTo(right.x, right.y);

		fRenderer.fContext.setStrokeWidth(fRenderer.fFont.Size() / 12.0f);
		fRenderer.fContext.setStrokeStyle(fRenderer.fColor);
		fRenderer.fContext.strokePath(path);
	}

private:
	const Transformable&	fTransform;
	const BPoint&			fTransformOffset;
	const IntRect&			fClippingFrame;
	bool					fDryRun;
	IntRect					fBounds;
	BPoint*					fNextCharPos;
	Blend2dTextRenderer&	fRenderer;
};

// ============================================================================
// Методы рендеринга
// ============================================================================

BRect
Blend2dTextRenderer::RenderString(const char* string, uint32 length,
	const BPoint& baseLine, const BRect& clippingFrame, bool dryRun,
	BPoint* nextCharPos, const escapement_delta* delta,
	FontCacheReference* cacheReference)
{
	Transformable transform(fTransform);
	transform.TranslateBy(baseLine);

	BPoint transformOffset(0.0, 0.0);
	transform.Transform(&transformOffset);
	IntRect clippingIntFrame(clippingFrame);

	StringRenderer renderer(clippingIntFrame, dryRun, transform,
		transformOffset, nextCharPos, *this);

	GlyphLayoutEngine::LayoutGlyphs(renderer, fFont, string, length, INT32_MAX,
		delta, fFont.Spacing(), NULL, cacheReference);

	return transform.TransformBounds(renderer.Bounds());
}

BRect
Blend2dTextRenderer::RenderString(const char* string, uint32 length,
	const BPoint* offsets, const BRect& clippingFrame, bool dryRun,
	BPoint* nextCharPos, FontCacheReference* cacheReference)
{
	Transformable transform(fTransform);

	BPoint transformOffset(0.0, 0.0);
	transform.Transform(&transformOffset);
	IntRect clippingIntFrame(clippingFrame);

	StringRenderer renderer(clippingIntFrame, dryRun, transform,
		transformOffset, nextCharPos, *this);

	GlyphLayoutEngine::LayoutGlyphs(renderer, fFont, string, length, INT32_MAX,
		NULL, fFont.Spacing(), offsets, cacheReference);

	return transform.TransformBounds(renderer.Bounds());
}
```

---

## Шаг 5: Обновление FontCacheEntry

**Изменения в:** `src/servers/app/font/FontCacheEntry.h`

Заменить AGG типы на blend2d:

```cpp
// Было:
typedef agg::conv_curve<GlyphPathAdapter>		CurveConverter;
typedef agg::conv_contour<CurveConverter>		ContourConverter;

// Стало:
typedef BLPath									PathType;

// Адаптеры больше не нужны - blend2d работает напрямую
```

**Изменения в:** `src/servers/app/font/FontCacheEntry.cpp`

Обновить методы работы с глифами для использования blend2d структур.

---

## Шаг 6: Ключевые моменты миграции

### 6.1 Перцептивный alpha вместо субпикселей

**Формула конвертации LCD RGB → Alpha:**
```cpp
// Коэффициенты основаны на восприятии яркости человеческим глазом
alpha = 0.299 * R + 0.587 * G + 0.114 * B
```

**Почему эти коэффициенты:**
- Человеческий глаз наиболее чувствителен к зеленому (0.587)
- Менее чувствителен к красному (0.299)  
- Наименее чувствителен к синему (0.114)

### 6.2 Типы данных глифов

| AGG | blend2d | Описание |
|-----|---------|----------|
| glyph_data_mono | glyph_data_mono | 1-бит монохром |
| glyph_data_gray8 | glyph_data_gray8 | 8-бит grayscale |
| glyph_data_subpix | glyph_data_lcd | LCD → перцептивный alpha |
| glyph_data_outline | glyph_data_outline | Векторные пути |

### 6.3 Сериализация данных

blend2d не имеет встроенной сериализации путей как AGG. Нужно реализовать:

```cpp
// Сохранение BLPath
struct PathData {
    size_t vertexCount;
    BLPoint vertices[];
    uint8_t commands[];
};
```

---
е

Эта миграция заменяет AGG на blend2d с минимальными изменениями публичного API:

✅ **Сохранено:** Имя класса `FontEngine`  
✅ **Сохранено:** Публичные методы и сигнатуры  
✅ **Заменено:** Внутренняя реализация на blend2d  
✅ **Улучшено:** Субпиксели → перцептивный alpha  

**Следующие шаги:**
1. Реализовать сериализацию BLPath
2. Завершить методы рендеринга в StringRenderer
3. Обновить FontCacheEntry полностью
4. Тестирование и сравнение с AGG
